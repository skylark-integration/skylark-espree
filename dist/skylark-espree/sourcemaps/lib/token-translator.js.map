{"version":3,"sources":["lib/token-translator.js"],"names":["define","Token","Boolean","EOF","Identifier","PrivateIdentifier","Keyword","Null","Numeric","Punctuator","String","RegularExpression","Template","JSXIdentifier","JSXText","TokenTranslator","acornTokTypes","code","this","_acornTokTypes","_tokens","_curlyBrace","_code","prototype","constructor","[object Object]","token","extra","type","tt","name","value","ecmaVersion","privateId","semi","comma","parenL","parenR","braceL","braceR","dot","bracketL","colon","question","bracketR","ellipsis","arrow","jsxTagStart","incDec","starstar","jsxTagEnd","prefix","questionDot","binop","keyword","isAssign","slice","start","end","jsxName","label","jsxAttrValueToken","num","string","regexp","regex","flags","pattern","that","tokens","templateTokens","translateTemplateTokens","push","firstToken","lastTemplateToken","length","loc","range","convertTemplatePart","eof","backQuote","translate","dollarBraceL","template","invalidTemplate"],"mappings":"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","file":"../../lib/token-translator.js","sourcesContent":["define([],function(){\n\n    /**\n     * @fileoverview Translates tokens between Acorn format and Esprima format.\n     * @author Nicholas C. Zakas\n     */\n    /* eslint no-underscore-dangle: 0 */\n\n    //------------------------------------------------------------------------------\n    // Requirements\n    //------------------------------------------------------------------------------\n\n    // none!\n\n    //------------------------------------------------------------------------------\n    // Private\n    //------------------------------------------------------------------------------\n\n\n    // Esprima Token Types\n    const Token = {\n        Boolean: \"Boolean\",\n        EOF: \"<end>\",\n        Identifier: \"Identifier\",\n        PrivateIdentifier: \"PrivateIdentifier\",\n        Keyword: \"Keyword\",\n        Null: \"Null\",\n        Numeric: \"Numeric\",\n        Punctuator: \"Punctuator\",\n        String: \"String\",\n        RegularExpression: \"RegularExpression\",\n        Template: \"Template\",\n        JSXIdentifier: \"JSXIdentifier\",\n        JSXText: \"JSXText\"\n    };\n\n    /**\n     * Converts part of a template into an Esprima token.\n     * @param {AcornToken[]} tokens The Acorn tokens representing the template.\n     * @param {string} code The source code.\n     * @returns {EsprimaToken} The Esprima equivalent of the template token.\n     * @private\n     */\n    function convertTemplatePart(tokens, code) {\n        const firstToken = tokens[0],\n            lastTemplateToken = tokens[tokens.length - 1];\n\n        const token = {\n            type: Token.Template,\n            value: code.slice(firstToken.start, lastTemplateToken.end)\n        };\n\n        if (firstToken.loc) {\n            token.loc = {\n                start: firstToken.loc.start,\n                end: lastTemplateToken.loc.end\n            };\n        }\n\n        if (firstToken.range) {\n            token.start = firstToken.range[0];\n            token.end = lastTemplateToken.range[1];\n            token.range = [token.start, token.end];\n        }\n\n        return token;\n    }\n\n    /**\n     * Contains logic to translate Acorn tokens into Esprima tokens.\n     * @param {Object} acornTokTypes The Acorn token types.\n     * @param {string} code The source code Acorn is parsing. This is necessary\n     *      to correct the \"value\" property of some tokens.\n     * @constructor\n     */\n    function TokenTranslator(acornTokTypes, code) {\n\n        // token types\n        this._acornTokTypes = acornTokTypes;\n\n        // token buffer for templates\n        this._tokens = [];\n\n        // track the last curly brace\n        this._curlyBrace = null;\n\n        // the source code\n        this._code = code;\n\n    }\n\n    TokenTranslator.prototype = {\n        constructor: TokenTranslator,\n\n        /**\n         * Translates a single Esprima token to a single Acorn token. This may be\n         * inaccurate due to how templates are handled differently in Esprima and\n         * Acorn, but should be accurate for all other tokens.\n         * @param {AcornToken} token The Acorn token to translate.\n         * @param {Object} extra Espree extra object.\n         * @returns {EsprimaToken} The Esprima version of the token.\n         */\n        translate(token, extra) {\n\n            const type = token.type,\n                tt = this._acornTokTypes;\n\n            if (type === tt.name) {\n                token.type = Token.Identifier;\n\n                // TODO: See if this is an Acorn bug\n                if (token.value === \"static\") {\n                    token.type = Token.Keyword;\n                }\n\n                if (extra.ecmaVersion > 5 && (token.value === \"yield\" || token.value === \"let\")) {\n                    token.type = Token.Keyword;\n                }\n\n            } else if (type === tt.privateId) {\n                token.type = Token.PrivateIdentifier;\n\n            } else if (type === tt.semi || type === tt.comma ||\n                     type === tt.parenL || type === tt.parenR ||\n                     type === tt.braceL || type === tt.braceR ||\n                     type === tt.dot || type === tt.bracketL ||\n                     type === tt.colon || type === tt.question ||\n                     type === tt.bracketR || type === tt.ellipsis ||\n                     type === tt.arrow || type === tt.jsxTagStart ||\n                     type === tt.incDec || type === tt.starstar ||\n                     type === tt.jsxTagEnd || type === tt.prefix ||\n                     type === tt.questionDot ||\n                     (type.binop && !type.keyword) ||\n                     type.isAssign) {\n\n                token.type = Token.Punctuator;\n                token.value = this._code.slice(token.start, token.end);\n            } else if (type === tt.jsxName) {\n                token.type = Token.JSXIdentifier;\n            } else if (type.label === \"jsxText\" || type === tt.jsxAttrValueToken) {\n                token.type = Token.JSXText;\n            } else if (type.keyword) {\n                if (type.keyword === \"true\" || type.keyword === \"false\") {\n                    token.type = Token.Boolean;\n                } else if (type.keyword === \"null\") {\n                    token.type = Token.Null;\n                } else {\n                    token.type = Token.Keyword;\n                }\n            } else if (type === tt.num) {\n                token.type = Token.Numeric;\n                token.value = this._code.slice(token.start, token.end);\n            } else if (type === tt.string) {\n\n                if (extra.jsxAttrValueToken) {\n                    extra.jsxAttrValueToken = false;\n                    token.type = Token.JSXText;\n                } else {\n                    token.type = Token.String;\n                }\n\n                token.value = this._code.slice(token.start, token.end);\n            } else if (type === tt.regexp) {\n                token.type = Token.RegularExpression;\n                const value = token.value;\n\n                token.regex = {\n                    flags: value.flags,\n                    pattern: value.pattern\n                };\n                token.value = `/${value.pattern}/${value.flags}`;\n            }\n\n            return token;\n        },\n\n        /**\n         * Function to call during Acorn's onToken handler.\n         * @param {AcornToken} token The Acorn token.\n         * @param {Object} extra The Espree extra object.\n         * @returns {void}\n         */\n        onToken(token, extra) {\n\n            const that = this,\n                tt = this._acornTokTypes,\n                tokens = extra.tokens,\n                templateTokens = this._tokens;\n\n            /**\n             * Flushes the buffered template tokens and resets the template\n             * tracking.\n             * @returns {void}\n             * @private\n             */\n            function translateTemplateTokens() {\n                tokens.push(convertTemplatePart(that._tokens, that._code));\n                that._tokens = [];\n            }\n\n            if (token.type === tt.eof) {\n\n                // might be one last curlyBrace\n                if (this._curlyBrace) {\n                    tokens.push(this.translate(this._curlyBrace, extra));\n                }\n\n                return;\n            }\n\n            if (token.type === tt.backQuote) {\n\n                // if there's already a curly, it's not part of the template\n                if (this._curlyBrace) {\n                    tokens.push(this.translate(this._curlyBrace, extra));\n                    this._curlyBrace = null;\n                }\n\n                templateTokens.push(token);\n\n                // it's the end\n                if (templateTokens.length > 1) {\n                    translateTemplateTokens();\n                }\n\n                return;\n            }\n            if (token.type === tt.dollarBraceL) {\n                templateTokens.push(token);\n                translateTemplateTokens();\n                return;\n            }\n            if (token.type === tt.braceR) {\n\n                // if there's already a curly, it's not part of the template\n                if (this._curlyBrace) {\n                    tokens.push(this.translate(this._curlyBrace, extra));\n                }\n\n                // store new curly for later\n                this._curlyBrace = token;\n                return;\n            }\n            if (token.type === tt.template || token.type === tt.invalidTemplate) {\n                if (this._curlyBrace) {\n                    templateTokens.push(this._curlyBrace);\n                    this._curlyBrace = null;\n                }\n\n                templateTokens.push(token);\n                return;\n            }\n\n            if (this._curlyBrace) {\n                tokens.push(this.translate(this._curlyBrace, extra));\n                this._curlyBrace = null;\n            }\n\n            tokens.push(this.translate(token, extra));\n        }\n    };\n\n    //------------------------------------------------------------------------------\n    // Public\n    //------------------------------------------------------------------------------\n\n    return TokenTranslator;\n\n});"]}