{"version":3,"sources":["skylark-espree.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-espree.js","sourcesContent":["define('skylark-acorn/plugins/jsx',[],function(){\r\n  const XHTMLEntities = {\r\n    quot: '\\u0022',\r\n    amp: '&',\r\n    apos: '\\u0027',\r\n    lt: '<',\r\n    gt: '>',\r\n    nbsp: '\\u00A0',\r\n    iexcl: '\\u00A1',\r\n    cent: '\\u00A2',\r\n    pound: '\\u00A3',\r\n    curren: '\\u00A4',\r\n    yen: '\\u00A5',\r\n    brvbar: '\\u00A6',\r\n    sect: '\\u00A7',\r\n    uml: '\\u00A8',\r\n    copy: '\\u00A9',\r\n    ordf: '\\u00AA',\r\n    laquo: '\\u00AB',\r\n    not: '\\u00AC',\r\n    shy: '\\u00AD',\r\n    reg: '\\u00AE',\r\n    macr: '\\u00AF',\r\n    deg: '\\u00B0',\r\n    plusmn: '\\u00B1',\r\n    sup2: '\\u00B2',\r\n    sup3: '\\u00B3',\r\n    acute: '\\u00B4',\r\n    micro: '\\u00B5',\r\n    para: '\\u00B6',\r\n    middot: '\\u00B7',\r\n    cedil: '\\u00B8',\r\n    sup1: '\\u00B9',\r\n    ordm: '\\u00BA',\r\n    raquo: '\\u00BB',\r\n    frac14: '\\u00BC',\r\n    frac12: '\\u00BD',\r\n    frac34: '\\u00BE',\r\n    iquest: '\\u00BF',\r\n    Agrave: '\\u00C0',\r\n    Aacute: '\\u00C1',\r\n    Acirc: '\\u00C2',\r\n    Atilde: '\\u00C3',\r\n    Auml: '\\u00C4',\r\n    Aring: '\\u00C5',\r\n    AElig: '\\u00C6',\r\n    Ccedil: '\\u00C7',\r\n    Egrave: '\\u00C8',\r\n    Eacute: '\\u00C9',\r\n    Ecirc: '\\u00CA',\r\n    Euml: '\\u00CB',\r\n    Igrave: '\\u00CC',\r\n    Iacute: '\\u00CD',\r\n    Icirc: '\\u00CE',\r\n    Iuml: '\\u00CF',\r\n    ETH: '\\u00D0',\r\n    Ntilde: '\\u00D1',\r\n    Ograve: '\\u00D2',\r\n    Oacute: '\\u00D3',\r\n    Ocirc: '\\u00D4',\r\n    Otilde: '\\u00D5',\r\n    Ouml: '\\u00D6',\r\n    times: '\\u00D7',\r\n    Oslash: '\\u00D8',\r\n    Ugrave: '\\u00D9',\r\n    Uacute: '\\u00DA',\r\n    Ucirc: '\\u00DB',\r\n    Uuml: '\\u00DC',\r\n    Yacute: '\\u00DD',\r\n    THORN: '\\u00DE',\r\n    szlig: '\\u00DF',\r\n    agrave: '\\u00E0',\r\n    aacute: '\\u00E1',\r\n    acirc: '\\u00E2',\r\n    atilde: '\\u00E3',\r\n    auml: '\\u00E4',\r\n    aring: '\\u00E5',\r\n    aelig: '\\u00E6',\r\n    ccedil: '\\u00E7',\r\n    egrave: '\\u00E8',\r\n    eacute: '\\u00E9',\r\n    ecirc: '\\u00EA',\r\n    euml: '\\u00EB',\r\n    igrave: '\\u00EC',\r\n    iacute: '\\u00ED',\r\n    icirc: '\\u00EE',\r\n    iuml: '\\u00EF',\r\n    eth: '\\u00F0',\r\n    ntilde: '\\u00F1',\r\n    ograve: '\\u00F2',\r\n    oacute: '\\u00F3',\r\n    ocirc: '\\u00F4',\r\n    otilde: '\\u00F5',\r\n    ouml: '\\u00F6',\r\n    divide: '\\u00F7',\r\n    oslash: '\\u00F8',\r\n    ugrave: '\\u00F9',\r\n    uacute: '\\u00FA',\r\n    ucirc: '\\u00FB',\r\n    uuml: '\\u00FC',\r\n    yacute: '\\u00FD',\r\n    thorn: '\\u00FE',\r\n    yuml: '\\u00FF',\r\n    OElig: '\\u0152',\r\n    oelig: '\\u0153',\r\n    Scaron: '\\u0160',\r\n    scaron: '\\u0161',\r\n    Yuml: '\\u0178',\r\n    fnof: '\\u0192',\r\n    circ: '\\u02C6',\r\n    tilde: '\\u02DC',\r\n    Alpha: '\\u0391',\r\n    Beta: '\\u0392',\r\n    Gamma: '\\u0393',\r\n    Delta: '\\u0394',\r\n    Epsilon: '\\u0395',\r\n    Zeta: '\\u0396',\r\n    Eta: '\\u0397',\r\n    Theta: '\\u0398',\r\n    Iota: '\\u0399',\r\n    Kappa: '\\u039A',\r\n    Lambda: '\\u039B',\r\n    Mu: '\\u039C',\r\n    Nu: '\\u039D',\r\n    Xi: '\\u039E',\r\n    Omicron: '\\u039F',\r\n    Pi: '\\u03A0',\r\n    Rho: '\\u03A1',\r\n    Sigma: '\\u03A3',\r\n    Tau: '\\u03A4',\r\n    Upsilon: '\\u03A5',\r\n    Phi: '\\u03A6',\r\n    Chi: '\\u03A7',\r\n    Psi: '\\u03A8',\r\n    Omega: '\\u03A9',\r\n    alpha: '\\u03B1',\r\n    beta: '\\u03B2',\r\n    gamma: '\\u03B3',\r\n    delta: '\\u03B4',\r\n    epsilon: '\\u03B5',\r\n    zeta: '\\u03B6',\r\n    eta: '\\u03B7',\r\n    theta: '\\u03B8',\r\n    iota: '\\u03B9',\r\n    kappa: '\\u03BA',\r\n    lambda: '\\u03BB',\r\n    mu: '\\u03BC',\r\n    nu: '\\u03BD',\r\n    xi: '\\u03BE',\r\n    omicron: '\\u03BF',\r\n    pi: '\\u03C0',\r\n    rho: '\\u03C1',\r\n    sigmaf: '\\u03C2',\r\n    sigma: '\\u03C3',\r\n    tau: '\\u03C4',\r\n    upsilon: '\\u03C5',\r\n    phi: '\\u03C6',\r\n    chi: '\\u03C7',\r\n    psi: '\\u03C8',\r\n    omega: '\\u03C9',\r\n    thetasym: '\\u03D1',\r\n    upsih: '\\u03D2',\r\n    piv: '\\u03D6',\r\n    ensp: '\\u2002',\r\n    emsp: '\\u2003',\r\n    thinsp: '\\u2009',\r\n    zwnj: '\\u200C',\r\n    zwj: '\\u200D',\r\n    lrm: '\\u200E',\r\n    rlm: '\\u200F',\r\n    ndash: '\\u2013',\r\n    mdash: '\\u2014',\r\n    lsquo: '\\u2018',\r\n    rsquo: '\\u2019',\r\n    sbquo: '\\u201A',\r\n    ldquo: '\\u201C',\r\n    rdquo: '\\u201D',\r\n    bdquo: '\\u201E',\r\n    dagger: '\\u2020',\r\n    Dagger: '\\u2021',\r\n    bull: '\\u2022',\r\n    hellip: '\\u2026',\r\n    permil: '\\u2030',\r\n    prime: '\\u2032',\r\n    Prime: '\\u2033',\r\n    lsaquo: '\\u2039',\r\n    rsaquo: '\\u203A',\r\n    oline: '\\u203E',\r\n    frasl: '\\u2044',\r\n    euro: '\\u20AC',\r\n    image: '\\u2111',\r\n    weierp: '\\u2118',\r\n    real: '\\u211C',\r\n    trade: '\\u2122',\r\n    alefsym: '\\u2135',\r\n    larr: '\\u2190',\r\n    uarr: '\\u2191',\r\n    rarr: '\\u2192',\r\n    darr: '\\u2193',\r\n    harr: '\\u2194',\r\n    crarr: '\\u21B5',\r\n    lArr: '\\u21D0',\r\n    uArr: '\\u21D1',\r\n    rArr: '\\u21D2',\r\n    dArr: '\\u21D3',\r\n    hArr: '\\u21D4',\r\n    forall: '\\u2200',\r\n    part: '\\u2202',\r\n    exist: '\\u2203',\r\n    empty: '\\u2205',\r\n    nabla: '\\u2207',\r\n    isin: '\\u2208',\r\n    notin: '\\u2209',\r\n    ni: '\\u220B',\r\n    prod: '\\u220F',\r\n    sum: '\\u2211',\r\n    minus: '\\u2212',\r\n    lowast: '\\u2217',\r\n    radic: '\\u221A',\r\n    prop: '\\u221D',\r\n    infin: '\\u221E',\r\n    ang: '\\u2220',\r\n    and: '\\u2227',\r\n    or: '\\u2228',\r\n    cap: '\\u2229',\r\n    cup: '\\u222A',\r\n    'int': '\\u222B',\r\n    there4: '\\u2234',\r\n    sim: '\\u223C',\r\n    cong: '\\u2245',\r\n    asymp: '\\u2248',\r\n    ne: '\\u2260',\r\n    equiv: '\\u2261',\r\n    le: '\\u2264',\r\n    ge: '\\u2265',\r\n    sub: '\\u2282',\r\n    sup: '\\u2283',\r\n    nsub: '\\u2284',\r\n    sube: '\\u2286',\r\n    supe: '\\u2287',\r\n    oplus: '\\u2295',\r\n    otimes: '\\u2297',\r\n    perp: '\\u22A5',\r\n    sdot: '\\u22C5',\r\n    lceil: '\\u2308',\r\n    rceil: '\\u2309',\r\n    lfloor: '\\u230A',\r\n    rfloor: '\\u230B',\r\n    lang: '\\u2329',\r\n    rang: '\\u232A',\r\n    loz: '\\u25CA',\r\n    spades: '\\u2660',\r\n    clubs: '\\u2663',\r\n    hearts: '\\u2665',\r\n    diams: '\\u2666'\r\n  };\r\n\r\n  const hexNumber = /^[\\da-fA-F]+$/;\r\n  const decimalNumber = /^\\d+$/;\r\n\r\n  // The map to `acorn-jsx` tokens from `acorn` namespace objects.\r\n  const acornJsxMap = new WeakMap();\r\n\r\n  // Get the original tokens for the given `acorn` namespace object.\r\n  function getJsxTokens(acorn) {\r\n    acorn = acorn.Parser.acorn || acorn;\r\n    let acornJsx = acornJsxMap.get(acorn);\r\n    if (!acornJsx) {\r\n      const tt = acorn.tokTypes;\r\n      const TokContext = acorn.TokContext;\r\n      const TokenType = acorn.TokenType;\r\n      const tc_oTag = new TokContext('<tag', false);\r\n      const tc_cTag = new TokContext('</tag', false);\r\n      const tc_expr = new TokContext('<tag>...</tag>', true, true);\r\n      const tokContexts = {\r\n        tc_oTag: tc_oTag,\r\n        tc_cTag: tc_cTag,\r\n        tc_expr: tc_expr\r\n      };\r\n      const tokTypes = {\r\n        jsxName: new TokenType('jsxName'),\r\n        jsxText: new TokenType('jsxText', {beforeExpr: true}),\r\n        jsxTagStart: new TokenType('jsxTagStart', {startsExpr: true}),\r\n        jsxTagEnd: new TokenType('jsxTagEnd')\r\n      };\r\n\r\n      tokTypes.jsxTagStart.updateContext = function() {\r\n        this.context.push(tc_expr); // treat as beginning of JSX expression\r\n        this.context.push(tc_oTag); // start opening tag context\r\n        this.exprAllowed = false;\r\n      };\r\n      tokTypes.jsxTagEnd.updateContext = function(prevType) {\r\n        let out = this.context.pop();\r\n        if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {\r\n          this.context.pop();\r\n          this.exprAllowed = this.curContext() === tc_expr;\r\n        } else {\r\n          this.exprAllowed = true;\r\n        }\r\n      };\r\n\r\n      acornJsx = { tokContexts: tokContexts, tokTypes: tokTypes };\r\n      acornJsxMap.set(acorn, acornJsx);\r\n    }\r\n\r\n    return acornJsx;\r\n  }\r\n\r\n  // Transforms JSX element name to string.\r\n\r\n  function getQualifiedJSXName(object) {\r\n    if (!object)\r\n      return object;\r\n\r\n    if (object.type === 'JSXIdentifier')\r\n      return object.name;\r\n\r\n    if (object.type === 'JSXNamespacedName')\r\n      return object.namespace.name + ':' + object.name.name;\r\n\r\n    if (object.type === 'JSXMemberExpression')\r\n      return getQualifiedJSXName(object.object) + '.' +\r\n      getQualifiedJSXName(object.property);\r\n  }\r\n\r\n  function jsx(options) {\r\n    options = options || {};\r\n    return function(Parser) {\r\n      return plugin({\r\n        allowNamespaces: options.allowNamespaces !== false,\r\n        allowNamespacedObjects: !!options.allowNamespacedObjects\r\n      }, Parser);\r\n    };\r\n  };\r\n\r\n  // This is `tokTypes` of the peer dep.\r\n  // This can be different instances from the actual `tokTypes` this plugin uses.\r\n  Object.defineProperty(jsx, \"tokTypes\", {\r\n    get: function get_tokTypes() {\r\n      return getJsxTokens(require(\"acorn\")).tokTypes;\r\n    },\r\n    configurable: true,\r\n    enumerable: true\r\n  });\r\n\r\n  function plugin(options, Parser) {\r\n    const acorn = Parser.acorn || require(\"acorn\");\r\n    const acornJsx = getJsxTokens(acorn);\r\n    const tt = acorn.tokTypes;\r\n    const tok = acornJsx.tokTypes;\r\n    const tokContexts = acorn.tokContexts;\r\n    const tc_oTag = acornJsx.tokContexts.tc_oTag;\r\n    const tc_cTag = acornJsx.tokContexts.tc_cTag;\r\n    const tc_expr = acornJsx.tokContexts.tc_expr;\r\n    const isNewLine = acorn.isNewLine;\r\n    const isIdentifierStart = acorn.isIdentifierStart;\r\n    const isIdentifierChar = acorn.isIdentifierChar;\r\n\r\n    return class extends Parser {\r\n      // Expose actual `tokTypes` and `tokContexts` to other plugins.\r\n      static get acornJsx() {\r\n        return acornJsx;\r\n      }\r\n\r\n      // Reads inline JSX contents token.\r\n      jsx_readToken() {\r\n        let out = '', chunkStart = this.pos;\r\n        for (;;) {\r\n          if (this.pos >= this.input.length)\r\n            this.raise(this.start, 'Unterminated JSX contents');\r\n          let ch = this.input.charCodeAt(this.pos);\r\n\r\n          switch (ch) {\r\n          case 60: // '<'\r\n          case 123: // '{'\r\n            if (this.pos === this.start) {\r\n              if (ch === 60 && this.exprAllowed) {\r\n                ++this.pos;\r\n                return this.finishToken(tok.jsxTagStart);\r\n              }\r\n              return this.getTokenFromCode(ch);\r\n            }\r\n            out += this.input.slice(chunkStart, this.pos);\r\n            return this.finishToken(tok.jsxText, out);\r\n\r\n          case 38: // '&'\r\n            out += this.input.slice(chunkStart, this.pos);\r\n            out += this.jsx_readEntity();\r\n            chunkStart = this.pos;\r\n            break;\r\n\r\n          case 62: // '>'\r\n          case 125: // '}'\r\n            this.raise(\r\n              this.pos,\r\n              \"Unexpected token `\" + this.input[this.pos] + \"`. Did you mean `\" +\r\n                (ch === 62 ? \"&gt;\" : \"&rbrace;\") + \"` or \" + \"`{\\\"\" + this.input[this.pos] + \"\\\"}\" + \"`?\"\r\n            );\r\n\r\n          default:\r\n            if (isNewLine(ch)) {\r\n              out += this.input.slice(chunkStart, this.pos);\r\n              out += this.jsx_readNewLine(true);\r\n              chunkStart = this.pos;\r\n            } else {\r\n              ++this.pos;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      jsx_readNewLine(normalizeCRLF) {\r\n        let ch = this.input.charCodeAt(this.pos);\r\n        let out;\r\n        ++this.pos;\r\n        if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {\r\n          ++this.pos;\r\n          out = normalizeCRLF ? '\\n' : '\\r\\n';\r\n        } else {\r\n          out = String.fromCharCode(ch);\r\n        }\r\n        if (this.options.locations) {\r\n          ++this.curLine;\r\n          this.lineStart = this.pos;\r\n        }\r\n\r\n        return out;\r\n      }\r\n\r\n      jsx_readString(quote) {\r\n        let out = '', chunkStart = ++this.pos;\r\n        for (;;) {\r\n          if (this.pos >= this.input.length)\r\n            this.raise(this.start, 'Unterminated string constant');\r\n          let ch = this.input.charCodeAt(this.pos);\r\n          if (ch === quote) break;\r\n          if (ch === 38) { // '&'\r\n            out += this.input.slice(chunkStart, this.pos);\r\n            out += this.jsx_readEntity();\r\n            chunkStart = this.pos;\r\n          } else if (isNewLine(ch)) {\r\n            out += this.input.slice(chunkStart, this.pos);\r\n            out += this.jsx_readNewLine(false);\r\n            chunkStart = this.pos;\r\n          } else {\r\n            ++this.pos;\r\n          }\r\n        }\r\n        out += this.input.slice(chunkStart, this.pos++);\r\n        return this.finishToken(tt.string, out);\r\n      }\r\n\r\n      jsx_readEntity() {\r\n        let str = '', count = 0, entity;\r\n        let ch = this.input[this.pos];\r\n        if (ch !== '&')\r\n          this.raise(this.pos, 'Entity must start with an ampersand');\r\n        let startPos = ++this.pos;\r\n        while (this.pos < this.input.length && count++ < 10) {\r\n          ch = this.input[this.pos++];\r\n          if (ch === ';') {\r\n            if (str[0] === '#') {\r\n              if (str[1] === 'x') {\r\n                str = str.substr(2);\r\n                if (hexNumber.test(str))\r\n                  entity = String.fromCharCode(parseInt(str, 16));\r\n              } else {\r\n                str = str.substr(1);\r\n                if (decimalNumber.test(str))\r\n                  entity = String.fromCharCode(parseInt(str, 10));\r\n              }\r\n            } else {\r\n              entity = XHTMLEntities[str];\r\n            }\r\n            break;\r\n          }\r\n          str += ch;\r\n        }\r\n        if (!entity) {\r\n          this.pos = startPos;\r\n          return '&';\r\n        }\r\n        return entity;\r\n      }\r\n\r\n      // Read a JSX identifier (valid tag or attribute name).\r\n      //\r\n      // Optimized version since JSX identifiers can't contain\r\n      // escape characters and so can be read as single slice.\r\n      // Also assumes that first character was already checked\r\n      // by isIdentifierStart in readToken.\r\n\r\n      jsx_readWord() {\r\n        let ch, start = this.pos;\r\n        do {\r\n          ch = this.input.charCodeAt(++this.pos);\r\n        } while (isIdentifierChar(ch) || ch === 45); // '-'\r\n        return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));\r\n      }\r\n\r\n      // Parse next token as JSX identifier\r\n\r\n      jsx_parseIdentifier() {\r\n        let node = this.startNode();\r\n        if (this.type === tok.jsxName)\r\n          node.name = this.value;\r\n        else if (this.type.keyword)\r\n          node.name = this.type.keyword;\r\n        else\r\n          this.unexpected();\r\n        this.next();\r\n        return this.finishNode(node, 'JSXIdentifier');\r\n      }\r\n\r\n      // Parse namespaced identifier.\r\n\r\n      jsx_parseNamespacedName() {\r\n        let startPos = this.start, startLoc = this.startLoc;\r\n        let name = this.jsx_parseIdentifier();\r\n        if (!options.allowNamespaces || !this.eat(tt.colon)) return name;\r\n        var node = this.startNodeAt(startPos, startLoc);\r\n        node.namespace = name;\r\n        node.name = this.jsx_parseIdentifier();\r\n        return this.finishNode(node, 'JSXNamespacedName');\r\n      }\r\n\r\n      // Parses element name in any form - namespaced, member\r\n      // or single identifier.\r\n\r\n      jsx_parseElementName() {\r\n        if (this.type === tok.jsxTagEnd) return '';\r\n        let startPos = this.start, startLoc = this.startLoc;\r\n        let node = this.jsx_parseNamespacedName();\r\n        if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !options.allowNamespacedObjects) {\r\n          this.unexpected();\r\n        }\r\n        while (this.eat(tt.dot)) {\r\n          let newNode = this.startNodeAt(startPos, startLoc);\r\n          newNode.object = node;\r\n          newNode.property = this.jsx_parseIdentifier();\r\n          node = this.finishNode(newNode, 'JSXMemberExpression');\r\n        }\r\n        return node;\r\n      }\r\n\r\n      // Parses any type of JSX attribute value.\r\n\r\n      jsx_parseAttributeValue() {\r\n        switch (this.type) {\r\n        case tt.braceL:\r\n          let node = this.jsx_parseExpressionContainer();\r\n          if (node.expression.type === 'JSXEmptyExpression')\r\n            this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');\r\n          return node;\r\n\r\n        case tok.jsxTagStart:\r\n        case tt.string:\r\n          return this.parseExprAtom();\r\n\r\n        default:\r\n          this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');\r\n        }\r\n      }\r\n\r\n      // JSXEmptyExpression is unique type since it doesn't actually parse anything,\r\n      // and so it should start at the end of last read token (left brace) and finish\r\n      // at the beginning of the next one (right brace).\r\n\r\n      jsx_parseEmptyExpression() {\r\n        let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\r\n        return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);\r\n      }\r\n\r\n      // Parses JSX expression enclosed into curly brackets.\r\n\r\n      jsx_parseExpressionContainer() {\r\n        let node = this.startNode();\r\n        this.next();\r\n        node.expression = this.type === tt.braceR\r\n          ? this.jsx_parseEmptyExpression()\r\n          : this.parseExpression();\r\n        this.expect(tt.braceR);\r\n        return this.finishNode(node, 'JSXExpressionContainer');\r\n      }\r\n\r\n      // Parses following JSX attribute name-value pair.\r\n\r\n      jsx_parseAttribute() {\r\n        let node = this.startNode();\r\n        if (this.eat(tt.braceL)) {\r\n          this.expect(tt.ellipsis);\r\n          node.argument = this.parseMaybeAssign();\r\n          this.expect(tt.braceR);\r\n          return this.finishNode(node, 'JSXSpreadAttribute');\r\n        }\r\n        node.name = this.jsx_parseNamespacedName();\r\n        node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;\r\n        return this.finishNode(node, 'JSXAttribute');\r\n      }\r\n\r\n      // Parses JSX opening tag starting after '<'.\r\n\r\n      jsx_parseOpeningElementAt(startPos, startLoc) {\r\n        let node = this.startNodeAt(startPos, startLoc);\r\n        node.attributes = [];\r\n        let nodeName = this.jsx_parseElementName();\r\n        if (nodeName) node.name = nodeName;\r\n        while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)\r\n          node.attributes.push(this.jsx_parseAttribute());\r\n        node.selfClosing = this.eat(tt.slash);\r\n        this.expect(tok.jsxTagEnd);\r\n        return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');\r\n      }\r\n\r\n      // Parses JSX closing tag starting after '</'.\r\n\r\n      jsx_parseClosingElementAt(startPos, startLoc) {\r\n        let node = this.startNodeAt(startPos, startLoc);\r\n        let nodeName = this.jsx_parseElementName();\r\n        if (nodeName) node.name = nodeName;\r\n        this.expect(tok.jsxTagEnd);\r\n        return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');\r\n      }\r\n\r\n      // Parses entire JSX element, including it's opening tag\r\n      // (starting after '<'), attributes, contents and closing tag.\r\n\r\n      jsx_parseElementAt(startPos, startLoc) {\r\n        let node = this.startNodeAt(startPos, startLoc);\r\n        let children = [];\r\n        let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);\r\n        let closingElement = null;\r\n\r\n        if (!openingElement.selfClosing) {\r\n          contents: for (;;) {\r\n            switch (this.type) {\r\n            case tok.jsxTagStart:\r\n              startPos = this.start; startLoc = this.startLoc;\r\n              this.next();\r\n              if (this.eat(tt.slash)) {\r\n                closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);\r\n                break contents;\r\n              }\r\n              children.push(this.jsx_parseElementAt(startPos, startLoc));\r\n              break;\r\n\r\n            case tok.jsxText:\r\n              children.push(this.parseExprAtom());\r\n              break;\r\n\r\n            case tt.braceL:\r\n              children.push(this.jsx_parseExpressionContainer());\r\n              break;\r\n\r\n            default:\r\n              this.unexpected();\r\n            }\r\n          }\r\n          if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\r\n            this.raise(\r\n              closingElement.start,\r\n              'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');\r\n          }\r\n        }\r\n        let fragmentOrElement = openingElement.name ? 'Element' : 'Fragment';\r\n\r\n        node['opening' + fragmentOrElement] = openingElement;\r\n        node['closing' + fragmentOrElement] = closingElement;\r\n        node.children = children;\r\n        if (this.type === tt.relational && this.value === \"<\") {\r\n          this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\r\n        }\r\n        return this.finishNode(node, 'JSX' + fragmentOrElement);\r\n      }\r\n\r\n      // Parse JSX text\r\n\r\n      jsx_parseText() {\r\n        let node = this.parseLiteral(this.value);\r\n        node.type = \"JSXText\";\r\n        return node;\r\n      }\r\n\r\n      // Parses entire JSX element from current position.\r\n\r\n      jsx_parseElement() {\r\n        let startPos = this.start, startLoc = this.startLoc;\r\n        this.next();\r\n        return this.jsx_parseElementAt(startPos, startLoc);\r\n      }\r\n\r\n      parseExprAtom(refShortHandDefaultPos) {\r\n        if (this.type === tok.jsxText)\r\n          return this.jsx_parseText();\r\n        else if (this.type === tok.jsxTagStart)\r\n          return this.jsx_parseElement();\r\n        else\r\n          return super.parseExprAtom(refShortHandDefaultPos);\r\n      }\r\n\r\n      readToken(code) {\r\n        let context = this.curContext();\r\n\r\n        if (context === tc_expr) return this.jsx_readToken();\r\n\r\n        if (context === tc_oTag || context === tc_cTag) {\r\n          if (isIdentifierStart(code)) return this.jsx_readWord();\r\n\r\n          if (code == 62) {\r\n            ++this.pos;\r\n            return this.finishToken(tok.jsxTagEnd);\r\n          }\r\n\r\n          if ((code === 34 || code === 39) && context == tc_oTag)\r\n            return this.jsx_readString(code);\r\n        }\r\n\r\n        if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {\r\n          ++this.pos;\r\n          return this.finishToken(tok.jsxTagStart);\r\n        }\r\n        return super.readToken(code);\r\n      }\r\n\r\n      updateContext(prevType) {\r\n        if (this.type == tt.braceL) {\r\n          var curContext = this.curContext();\r\n          if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);\r\n          else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);\r\n          else super.updateContext(prevType);\r\n          this.exprAllowed = true;\r\n        } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {\r\n          this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\r\n          this.context.push(tc_cTag); // reconsider as closing tag context\r\n          this.exprAllowed = false;\r\n        } else {\r\n          return super.updateContext(prevType);\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  return jsx;\r\n});\ndefine('skylark-espree/lib/token-translator',[],function(){\n\n    /**\n     * @fileoverview Translates tokens between Acorn format and Esprima format.\n     * @author Nicholas C. Zakas\n     */\n    /* eslint no-underscore-dangle: 0 */\n\n    //------------------------------------------------------------------------------\n    // Requirements\n    //------------------------------------------------------------------------------\n\n    // none!\n\n    //------------------------------------------------------------------------------\n    // Private\n    //------------------------------------------------------------------------------\n\n\n    // Esprima Token Types\n    const Token = {\n        Boolean: \"Boolean\",\n        EOF: \"<end>\",\n        Identifier: \"Identifier\",\n        PrivateIdentifier: \"PrivateIdentifier\",\n        Keyword: \"Keyword\",\n        Null: \"Null\",\n        Numeric: \"Numeric\",\n        Punctuator: \"Punctuator\",\n        String: \"String\",\n        RegularExpression: \"RegularExpression\",\n        Template: \"Template\",\n        JSXIdentifier: \"JSXIdentifier\",\n        JSXText: \"JSXText\"\n    };\n\n    /**\n     * Converts part of a template into an Esprima token.\n     * @param {AcornToken[]} tokens The Acorn tokens representing the template.\n     * @param {string} code The source code.\n     * @returns {EsprimaToken} The Esprima equivalent of the template token.\n     * @private\n     */\n    function convertTemplatePart(tokens, code) {\n        const firstToken = tokens[0],\n            lastTemplateToken = tokens[tokens.length - 1];\n\n        const token = {\n            type: Token.Template,\n            value: code.slice(firstToken.start, lastTemplateToken.end)\n        };\n\n        if (firstToken.loc) {\n            token.loc = {\n                start: firstToken.loc.start,\n                end: lastTemplateToken.loc.end\n            };\n        }\n\n        if (firstToken.range) {\n            token.start = firstToken.range[0];\n            token.end = lastTemplateToken.range[1];\n            token.range = [token.start, token.end];\n        }\n\n        return token;\n    }\n\n    /**\n     * Contains logic to translate Acorn tokens into Esprima tokens.\n     * @param {Object} acornTokTypes The Acorn token types.\n     * @param {string} code The source code Acorn is parsing. This is necessary\n     *      to correct the \"value\" property of some tokens.\n     * @constructor\n     */\n    function TokenTranslator(acornTokTypes, code) {\n\n        // token types\n        this._acornTokTypes = acornTokTypes;\n\n        // token buffer for templates\n        this._tokens = [];\n\n        // track the last curly brace\n        this._curlyBrace = null;\n\n        // the source code\n        this._code = code;\n\n    }\n\n    TokenTranslator.prototype = {\n        constructor: TokenTranslator,\n\n        /**\n         * Translates a single Esprima token to a single Acorn token. This may be\n         * inaccurate due to how templates are handled differently in Esprima and\n         * Acorn, but should be accurate for all other tokens.\n         * @param {AcornToken} token The Acorn token to translate.\n         * @param {Object} extra Espree extra object.\n         * @returns {EsprimaToken} The Esprima version of the token.\n         */\n        translate(token, extra) {\n\n            const type = token.type,\n                tt = this._acornTokTypes;\n\n            if (type === tt.name) {\n                token.type = Token.Identifier;\n\n                // TODO: See if this is an Acorn bug\n                if (token.value === \"static\") {\n                    token.type = Token.Keyword;\n                }\n\n                if (extra.ecmaVersion > 5 && (token.value === \"yield\" || token.value === \"let\")) {\n                    token.type = Token.Keyword;\n                }\n\n            } else if (type === tt.privateId) {\n                token.type = Token.PrivateIdentifier;\n\n            } else if (type === tt.semi || type === tt.comma ||\n                     type === tt.parenL || type === tt.parenR ||\n                     type === tt.braceL || type === tt.braceR ||\n                     type === tt.dot || type === tt.bracketL ||\n                     type === tt.colon || type === tt.question ||\n                     type === tt.bracketR || type === tt.ellipsis ||\n                     type === tt.arrow || type === tt.jsxTagStart ||\n                     type === tt.incDec || type === tt.starstar ||\n                     type === tt.jsxTagEnd || type === tt.prefix ||\n                     type === tt.questionDot ||\n                     (type.binop && !type.keyword) ||\n                     type.isAssign) {\n\n                token.type = Token.Punctuator;\n                token.value = this._code.slice(token.start, token.end);\n            } else if (type === tt.jsxName) {\n                token.type = Token.JSXIdentifier;\n            } else if (type.label === \"jsxText\" || type === tt.jsxAttrValueToken) {\n                token.type = Token.JSXText;\n            } else if (type.keyword) {\n                if (type.keyword === \"true\" || type.keyword === \"false\") {\n                    token.type = Token.Boolean;\n                } else if (type.keyword === \"null\") {\n                    token.type = Token.Null;\n                } else {\n                    token.type = Token.Keyword;\n                }\n            } else if (type === tt.num) {\n                token.type = Token.Numeric;\n                token.value = this._code.slice(token.start, token.end);\n            } else if (type === tt.string) {\n\n                if (extra.jsxAttrValueToken) {\n                    extra.jsxAttrValueToken = false;\n                    token.type = Token.JSXText;\n                } else {\n                    token.type = Token.String;\n                }\n\n                token.value = this._code.slice(token.start, token.end);\n            } else if (type === tt.regexp) {\n                token.type = Token.RegularExpression;\n                const value = token.value;\n\n                token.regex = {\n                    flags: value.flags,\n                    pattern: value.pattern\n                };\n                token.value = `/${value.pattern}/${value.flags}`;\n            }\n\n            return token;\n        },\n\n        /**\n         * Function to call during Acorn's onToken handler.\n         * @param {AcornToken} token The Acorn token.\n         * @param {Object} extra The Espree extra object.\n         * @returns {void}\n         */\n        onToken(token, extra) {\n\n            const that = this,\n                tt = this._acornTokTypes,\n                tokens = extra.tokens,\n                templateTokens = this._tokens;\n\n            /**\n             * Flushes the buffered template tokens and resets the template\n             * tracking.\n             * @returns {void}\n             * @private\n             */\n            function translateTemplateTokens() {\n                tokens.push(convertTemplatePart(that._tokens, that._code));\n                that._tokens = [];\n            }\n\n            if (token.type === tt.eof) {\n\n                // might be one last curlyBrace\n                if (this._curlyBrace) {\n                    tokens.push(this.translate(this._curlyBrace, extra));\n                }\n\n                return;\n            }\n\n            if (token.type === tt.backQuote) {\n\n                // if there's already a curly, it's not part of the template\n                if (this._curlyBrace) {\n                    tokens.push(this.translate(this._curlyBrace, extra));\n                    this._curlyBrace = null;\n                }\n\n                templateTokens.push(token);\n\n                // it's the end\n                if (templateTokens.length > 1) {\n                    translateTemplateTokens();\n                }\n\n                return;\n            }\n            if (token.type === tt.dollarBraceL) {\n                templateTokens.push(token);\n                translateTemplateTokens();\n                return;\n            }\n            if (token.type === tt.braceR) {\n\n                // if there's already a curly, it's not part of the template\n                if (this._curlyBrace) {\n                    tokens.push(this.translate(this._curlyBrace, extra));\n                }\n\n                // store new curly for later\n                this._curlyBrace = token;\n                return;\n            }\n            if (token.type === tt.template || token.type === tt.invalidTemplate) {\n                if (this._curlyBrace) {\n                    templateTokens.push(this._curlyBrace);\n                    this._curlyBrace = null;\n                }\n\n                templateTokens.push(token);\n                return;\n            }\n\n            if (this._curlyBrace) {\n                tokens.push(this.translate(this._curlyBrace, extra));\n                this._curlyBrace = null;\n            }\n\n            tokens.push(this.translate(token, extra));\n        }\n    };\n\n    //------------------------------------------------------------------------------\n    // Public\n    //------------------------------------------------------------------------------\n\n    return TokenTranslator;\n\n});\ndefine('skylark-espree/lib/options',[],function(){\n\n    /**\n     * @fileoverview A collection of methods for processing Espree's options.\n     * @author Kai Cataldo\n     */\n\n    //------------------------------------------------------------------------------\n    // Helpers\n    //------------------------------------------------------------------------------\n\n    const SUPPORTED_VERSIONS = [\n        3,\n        5,\n        6, // 2015\n        7, // 2016\n        8, // 2017\n        9, // 2018\n        10, // 2019\n        11, // 2020\n        12, // 2021\n        13, // 2022\n        14, // 2023\n        15 // 2024\n    ];\n\n    /**\n     * Get the latest ECMAScript version supported by Espree.\n     * @returns {number} The latest ECMAScript version.\n     */\n    function getLatestEcmaVersion() {\n        return SUPPORTED_VERSIONS[SUPPORTED_VERSIONS.length - 1];\n    }\n\n    /**\n     * Get the list of ECMAScript versions supported by Espree.\n     * @returns {number[]} An array containing the supported ECMAScript versions.\n     */\n    function getSupportedEcmaVersions() {\n        return [...SUPPORTED_VERSIONS];\n    }\n\n    /**\n     * Normalize ECMAScript version from the initial config\n     * @param {(number|\"latest\")} ecmaVersion ECMAScript version from the initial config\n     * @throws {Error} throws an error if the ecmaVersion is invalid.\n     * @returns {number} normalized ECMAScript version\n     */\n    function normalizeEcmaVersion(ecmaVersion = 'latest') { //5 lwf\n\n        let version = ecmaVersion === \"latest\" ? getLatestEcmaVersion() : ecmaVersion;\n\n        if (typeof version !== \"number\") {\n            throw new Error(`ecmaVersion must be a number or \"latest\". Received value of type ${typeof ecmaVersion} instead.`);\n        }\n\n        // Calculate ECMAScript edition number from official year version starting with\n        // ES2015, which corresponds with ES6 (or a difference of 2009).\n        if (version >= 2015) {\n            version -= 2009;\n        }\n\n        if (!SUPPORTED_VERSIONS.includes(version)) {\n            throw new Error(\"Invalid ecmaVersion.\");\n        }\n\n        return version;\n    }\n\n    /**\n     * Normalize sourceType from the initial config\n     * @param {string} sourceType to normalize\n     * @throws {Error} throw an error if sourceType is invalid\n     * @returns {string} normalized sourceType\n     */\n    function normalizeSourceType(sourceType = \"script\") {\n        if (sourceType === \"script\" || sourceType === \"module\") {\n            return sourceType;\n        }\n\n        if (sourceType === \"commonjs\") {\n            return \"script\";\n        }\n\n        throw new Error(\"Invalid sourceType.\");\n    }\n\n    /**\n     * Normalize parserOptions\n     * @param {Object} options the parser options to normalize\n     * @throws {Error} throw an error if found invalid option.\n     * @returns {Object} normalized options\n     */\n    function normalizeOptions(options) {\n        const ecmaVersion = normalizeEcmaVersion(options.ecmaVersion);\n        const sourceType = normalizeSourceType(options.sourceType);\n        const ranges = options.range === true;\n        const locations = options.loc === true;\n\n        if (ecmaVersion !== 3 && options.allowReserved) {\n\n            // a value of `false` is intentionally allowed here, so a shared config can overwrite it when needed\n            throw new Error(\"`allowReserved` is only supported when ecmaVersion is 3\");\n        }\n        if (typeof options.allowReserved !== \"undefined\" && typeof options.allowReserved !== \"boolean\") {\n            throw new Error(\"`allowReserved`, when present, must be `true` or `false`\");\n        }\n        const allowReserved = ecmaVersion === 3 ? (options.allowReserved || \"never\") : false;\n        const ecmaFeatures = options.ecmaFeatures || {};\n        const allowReturnOutsideFunction = options.sourceType === \"commonjs\" ||\n            Boolean(ecmaFeatures.globalReturn);\n\n        if (sourceType === \"module\" && ecmaVersion < 6) {\n            throw new Error(\"sourceType 'module' is not supported when ecmaVersion < 2015. Consider adding `{ ecmaVersion: 2015 }` to the parser options.\");\n        }\n\n        return Object.assign({}, options, {\n            ecmaVersion,\n            sourceType,\n            ranges,\n            locations,\n            allowReserved,\n            allowReturnOutsideFunction\n        });\n    }\n\n\n    return {\n        getLatestEcmaVersion,\n        getSupportedEcmaVersions,\n        normalizeOptions\n    };\n\n});\ndefine('skylark-espree/lib/espree',[\n    \"./token-translator\",\n    \"./options\"\n],function(TokenTranslator,options){\n\n    /* eslint-disable no-param-reassign*/\n    const  { normalizeOptions } = options;\n\n\n    const STATE = Symbol(\"espree's internal state\");\n    const ESPRIMA_FINISH_NODE = Symbol(\"espree's esprimaFinishNode\");\n\n\n    /**\n     * Converts an Acorn comment to a Esprima comment.\n     * @param {boolean} block True if it's a block comment, false if not.\n     * @param {string} text The text of the comment.\n     * @param {int} start The index at which the comment starts.\n     * @param {int} end The index at which the comment ends.\n     * @param {Location} startLoc The location at which the comment starts.\n     * @param {Location} endLoc The location at which the comment ends.\n     * @param {string} code The source code being parsed.\n     * @returns {Object} The comment object.\n     * @private\n     */\n    function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code) {\n        let type;\n\n        if (block) {\n            type = \"Block\";\n        } else if (code.slice(start, start + 2) === \"#!\") {\n            type = \"Hashbang\";\n        } else {\n            type = \"Line\";\n        }\n\n        const comment = {\n            type,\n            value: text\n        };\n\n        if (typeof start === \"number\") {\n            comment.start = start;\n            comment.end = end;\n            comment.range = [start, end];\n        }\n\n        if (typeof startLoc === \"object\") {\n            comment.loc = {\n                start: startLoc,\n                end: endLoc\n            };\n        }\n\n        return comment;\n    }\n\n    return () => Parser => {\n        const tokTypes = Object.assign({}, Parser.acorn.tokTypes);\n\n        if (Parser.acornJsx) {\n            Object.assign(tokTypes, Parser.acornJsx.tokTypes);\n        }\n\n        return class Espree extends Parser {\n            constructor(opts, code) {\n                if (typeof opts !== \"object\" || opts === null) {\n                    opts = {};\n                }\n                if (typeof code !== \"string\" && !(code instanceof String)) {\n                    code = String(code);\n                }\n\n                // save original source type in case of commonjs\n                const originalSourceType = opts.sourceType;\n                const options = normalizeOptions(opts);\n                const ecmaFeatures = options.ecmaFeatures || {};\n                const tokenTranslator =\n                    options.tokens === true\n                        ? new TokenTranslator(tokTypes, code)\n                        : null;\n\n                /*\n                 * Data that is unique to Espree and is not represented internally\n                 * in Acorn.\n                 *\n                 * For ES2023 hashbangs, Espree will call `onComment()` during the\n                 * constructor, so we must define state before having access to\n                 * `this`.\n                 */\n                const state = {\n                    originalSourceType: originalSourceType || options.sourceType,\n                    tokens: tokenTranslator ? [] : null,\n                    comments: options.comment === true ? [] : null,\n                    impliedStrict: ecmaFeatures.impliedStrict === true && options.ecmaVersion >= 5,\n                    ecmaVersion: options.ecmaVersion,\n                    jsxAttrValueToken: false,\n                    lastToken: null,\n                    templateElements: []\n                };\n\n                // Initialize acorn parser.\n                super({\n\n                    // do not use spread, because we don't want to pass any unknown options to acorn\n                    ecmaVersion: options.ecmaVersion,\n                    sourceType: options.sourceType,\n                    ranges: options.ranges,\n                    locations: options.locations,\n                    allowReserved: options.allowReserved,\n\n                    // Truthy value is true for backward compatibility.\n                    allowReturnOutsideFunction: options.allowReturnOutsideFunction,\n\n                    // Collect tokens\n                    onToken: token => {\n                        if (tokenTranslator) {\n\n                            // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.\n                            tokenTranslator.onToken(token, state);\n                        }\n                        if (token.type !== tokTypes.eof) {\n                            state.lastToken = token;\n                        }\n                    },\n\n                    // Collect comments\n                    onComment: (block, text, start, end, startLoc, endLoc) => {\n                        if (state.comments) {\n                            const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code);\n\n                            state.comments.push(comment);\n                        }\n                    }\n                }, code);\n\n                /*\n                 * We put all of this data into a symbol property as a way to avoid\n                 * potential naming conflicts with future versions of Acorn.\n                 */\n                this[STATE] = state;\n            }\n\n            tokenize() {\n                do {\n                    this.next();\n                } while (this.type !== tokTypes.eof);\n\n                // Consume the final eof token\n                this.next();\n\n                const extra = this[STATE];\n                const tokens = extra.tokens;\n\n                if (extra.comments) {\n                    tokens.comments = extra.comments;\n                }\n\n                return tokens;\n            }\n\n            finishNode(...args) {\n                const result = super.finishNode(...args);\n\n                return this[ESPRIMA_FINISH_NODE](result);\n            }\n\n            finishNodeAt(...args) {\n                const result = super.finishNodeAt(...args);\n\n                return this[ESPRIMA_FINISH_NODE](result);\n            }\n\n            parse() {\n                const extra = this[STATE];\n                const program = super.parse();\n\n                program.sourceType = extra.originalSourceType;\n\n                if (extra.comments) {\n                    program.comments = extra.comments;\n                }\n                if (extra.tokens) {\n                    program.tokens = extra.tokens;\n                }\n\n                /*\n                 * Adjust opening and closing position of program to match Esprima.\n                 * Acorn always starts programs at range 0 whereas Esprima starts at the\n                 * first AST node's start (the only real difference is when there's leading\n                 * whitespace or leading comments). Acorn also counts trailing whitespace\n                 * as part of the program whereas Esprima only counts up to the last token.\n                 */\n                if (program.body.length) {\n                    const [firstNode] = program.body;\n\n                    if (program.range) {\n                        program.range[0] = firstNode.range[0];\n                    }\n                    if (program.loc) {\n                        program.loc.start = firstNode.loc.start;\n                    }\n                    program.start = firstNode.start;\n                }\n                if (extra.lastToken) {\n                    if (program.range) {\n                        program.range[1] = extra.lastToken.range[1];\n                    }\n                    if (program.loc) {\n                        program.loc.end = extra.lastToken.loc.end;\n                    }\n                    program.end = extra.lastToken.end;\n                }\n\n\n                /*\n                 * https://github.com/eslint/espree/issues/349\n                 * Ensure that template elements have correct range information.\n                 * This is one location where Acorn produces a different value\n                 * for its start and end properties vs. the values present in the\n                 * range property. In order to avoid confusion, we set the start\n                 * and end properties to the values that are present in range.\n                 * This is done here, instead of in finishNode(), because Acorn\n                 * uses the values of start and end internally while parsing, making\n                 * it dangerous to change those values while parsing is ongoing.\n                 * By waiting until the end of parsing, we can safely change these\n                 * values without affect any other part of the process.\n                 */\n                this[STATE].templateElements.forEach(templateElement => {\n                    const startOffset = -1;\n                    const endOffset = templateElement.tail ? 1 : 2;\n\n                    templateElement.start += startOffset;\n                    templateElement.end += endOffset;\n\n                    if (templateElement.range) {\n                        templateElement.range[0] += startOffset;\n                        templateElement.range[1] += endOffset;\n                    }\n\n                    if (templateElement.loc) {\n                        templateElement.loc.start.column += startOffset;\n                        templateElement.loc.end.column += endOffset;\n                    }\n                });\n\n                return program;\n            }\n\n            parseTopLevel(node) {\n                if (this[STATE].impliedStrict) {\n                    this.strict = true;\n                }\n                return super.parseTopLevel(node);\n            }\n\n            /**\n             * Overwrites the default raise method to throw Esprima-style errors.\n             * @param {int} pos The position of the error.\n             * @param {string} message The error message.\n             * @throws {SyntaxError} A syntax error.\n             * @returns {void}\n             */\n            raise(pos, message) {\n                const loc = Parser.acorn.getLineInfo(this.input, pos);\n                const err = new SyntaxError(message);\n\n                err.index = pos;\n                err.lineNumber = loc.line;\n                err.column = loc.column + 1; // acorn uses 0-based columns\n                throw err;\n            }\n\n            /**\n             * Overwrites the default raise method to throw Esprima-style errors.\n             * @param {int} pos The position of the error.\n             * @param {string} message The error message.\n             * @throws {SyntaxError} A syntax error.\n             * @returns {void}\n             */\n            raiseRecoverable(pos, message) {\n                this.raise(pos, message);\n            }\n\n            /**\n             * Overwrites the default unexpected method to throw Esprima-style errors.\n             * @param {int} pos The position of the error.\n             * @throws {SyntaxError} A syntax error.\n             * @returns {void}\n             */\n            unexpected(pos) {\n                let message = \"Unexpected token\";\n\n                if (pos !== null && pos !== void 0) {\n                    this.pos = pos;\n\n                    if (this.options.locations) {\n                        while (this.pos < this.lineStart) {\n                            this.lineStart = this.input.lastIndexOf(\"\\n\", this.lineStart - 2) + 1;\n                            --this.curLine;\n                        }\n                    }\n\n                    this.nextToken();\n                }\n\n                if (this.end > this.start) {\n                    message += ` ${this.input.slice(this.start, this.end)}`;\n                }\n\n                this.raise(this.start, message);\n            }\n\n            /*\n            * Esprima-FB represents JSX strings as tokens called \"JSXText\", but Acorn-JSX\n            * uses regular tt.string without any distinction between this and regular JS\n            * strings. As such, we intercept an attempt to read a JSX string and set a flag\n            * on extra so that when tokens are converted, the next token will be switched\n            * to JSXText via onToken.\n            */\n            jsx_readString(quote) { // eslint-disable-line camelcase\n                const result = super.jsx_readString(quote);\n\n                if (this.type === tokTypes.string) {\n                    this[STATE].jsxAttrValueToken = true;\n                }\n                return result;\n            }\n\n            /**\n             * Performs last-minute Esprima-specific compatibility checks and fixes.\n             * @param {ASTNode} result The node to check.\n             * @returns {ASTNode} The finished node.\n             */\n            [ESPRIMA_FINISH_NODE](result) {\n\n                // Acorn doesn't count the opening and closing backticks as part of templates\n                // so we have to adjust ranges/locations appropriately.\n                if (result.type === \"TemplateElement\") {\n\n                    // save template element references to fix start/end later\n                    this[STATE].templateElements.push(result);\n                }\n\n                if (result.type.includes(\"Function\") && !result.generator) {\n                    result.generator = false;\n                }\n\n                return result;\n            }\n        };\n    };\n\n\n});\ndefine('skylark-espree/lib/version',[],function(){\n\tconst version = \"main\";\n\n\treturn version;\n\n});\n\ndefine('skylark-espree/eslint-visitor-keys',[],function(){\r\n\t/**\r\n\t * @typedef {{ readonly [type: string]: ReadonlyArray<string> }} VisitorKeys\r\n\t */\r\n\r\n\t/**\r\n\t * @type {VisitorKeys}\r\n\t */\r\n\tconst KEYS = {\r\n\t    ArrayExpression: [\r\n\t        \"elements\"\r\n\t    ],\r\n\t    ArrayPattern: [\r\n\t        \"elements\"\r\n\t    ],\r\n\t    ArrowFunctionExpression: [\r\n\t        \"params\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    AssignmentExpression: [\r\n\t        \"left\",\r\n\t        \"right\"\r\n\t    ],\r\n\t    AssignmentPattern: [\r\n\t        \"left\",\r\n\t        \"right\"\r\n\t    ],\r\n\t    AwaitExpression: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    BinaryExpression: [\r\n\t        \"left\",\r\n\t        \"right\"\r\n\t    ],\r\n\t    BlockStatement: [\r\n\t        \"body\"\r\n\t    ],\r\n\t    BreakStatement: [\r\n\t        \"label\"\r\n\t    ],\r\n\t    CallExpression: [\r\n\t        \"callee\",\r\n\t        \"arguments\"\r\n\t    ],\r\n\t    CatchClause: [\r\n\t        \"param\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    ChainExpression: [\r\n\t        \"expression\"\r\n\t    ],\r\n\t    ClassBody: [\r\n\t        \"body\"\r\n\t    ],\r\n\t    ClassDeclaration: [\r\n\t        \"id\",\r\n\t        \"superClass\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    ClassExpression: [\r\n\t        \"id\",\r\n\t        \"superClass\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    ConditionalExpression: [\r\n\t        \"test\",\r\n\t        \"consequent\",\r\n\t        \"alternate\"\r\n\t    ],\r\n\t    ContinueStatement: [\r\n\t        \"label\"\r\n\t    ],\r\n\t    DebuggerStatement: [],\r\n\t    DoWhileStatement: [\r\n\t        \"body\",\r\n\t        \"test\"\r\n\t    ],\r\n\t    EmptyStatement: [],\r\n\t    ExperimentalRestProperty: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    ExperimentalSpreadProperty: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    ExportAllDeclaration: [\r\n\t        \"exported\",\r\n\t        \"source\"\r\n\t    ],\r\n\t    ExportDefaultDeclaration: [\r\n\t        \"declaration\"\r\n\t    ],\r\n\t    ExportNamedDeclaration: [\r\n\t        \"declaration\",\r\n\t        \"specifiers\",\r\n\t        \"source\"\r\n\t    ],\r\n\t    ExportSpecifier: [\r\n\t        \"exported\",\r\n\t        \"local\"\r\n\t    ],\r\n\t    ExpressionStatement: [\r\n\t        \"expression\"\r\n\t    ],\r\n\t    ForInStatement: [\r\n\t        \"left\",\r\n\t        \"right\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    ForOfStatement: [\r\n\t        \"left\",\r\n\t        \"right\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    ForStatement: [\r\n\t        \"init\",\r\n\t        \"test\",\r\n\t        \"update\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    FunctionDeclaration: [\r\n\t        \"id\",\r\n\t        \"params\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    FunctionExpression: [\r\n\t        \"id\",\r\n\t        \"params\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    Identifier: [],\r\n\t    IfStatement: [\r\n\t        \"test\",\r\n\t        \"consequent\",\r\n\t        \"alternate\"\r\n\t    ],\r\n\t    ImportDeclaration: [\r\n\t        \"specifiers\",\r\n\t        \"source\"\r\n\t    ],\r\n\t    ImportDefaultSpecifier: [\r\n\t        \"local\"\r\n\t    ],\r\n\t    ImportExpression: [\r\n\t        \"source\"\r\n\t    ],\r\n\t    ImportNamespaceSpecifier: [\r\n\t        \"local\"\r\n\t    ],\r\n\t    ImportSpecifier: [\r\n\t        \"imported\",\r\n\t        \"local\"\r\n\t    ],\r\n\t    JSXAttribute: [\r\n\t        \"name\",\r\n\t        \"value\"\r\n\t    ],\r\n\t    JSXClosingElement: [\r\n\t        \"name\"\r\n\t    ],\r\n\t    JSXClosingFragment: [],\r\n\t    JSXElement: [\r\n\t        \"openingElement\",\r\n\t        \"children\",\r\n\t        \"closingElement\"\r\n\t    ],\r\n\t    JSXEmptyExpression: [],\r\n\t    JSXExpressionContainer: [\r\n\t        \"expression\"\r\n\t    ],\r\n\t    JSXFragment: [\r\n\t        \"openingFragment\",\r\n\t        \"children\",\r\n\t        \"closingFragment\"\r\n\t    ],\r\n\t    JSXIdentifier: [],\r\n\t    JSXMemberExpression: [\r\n\t        \"object\",\r\n\t        \"property\"\r\n\t    ],\r\n\t    JSXNamespacedName: [\r\n\t        \"namespace\",\r\n\t        \"name\"\r\n\t    ],\r\n\t    JSXOpeningElement: [\r\n\t        \"name\",\r\n\t        \"attributes\"\r\n\t    ],\r\n\t    JSXOpeningFragment: [],\r\n\t    JSXSpreadAttribute: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    JSXSpreadChild: [\r\n\t        \"expression\"\r\n\t    ],\r\n\t    JSXText: [],\r\n\t    LabeledStatement: [\r\n\t        \"label\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    Literal: [],\r\n\t    LogicalExpression: [\r\n\t        \"left\",\r\n\t        \"right\"\r\n\t    ],\r\n\t    MemberExpression: [\r\n\t        \"object\",\r\n\t        \"property\"\r\n\t    ],\r\n\t    MetaProperty: [\r\n\t        \"meta\",\r\n\t        \"property\"\r\n\t    ],\r\n\t    MethodDefinition: [\r\n\t        \"key\",\r\n\t        \"value\"\r\n\t    ],\r\n\t    NewExpression: [\r\n\t        \"callee\",\r\n\t        \"arguments\"\r\n\t    ],\r\n\t    ObjectExpression: [\r\n\t        \"properties\"\r\n\t    ],\r\n\t    ObjectPattern: [\r\n\t        \"properties\"\r\n\t    ],\r\n\t    PrivateIdentifier: [],\r\n\t    Program: [\r\n\t        \"body\"\r\n\t    ],\r\n\t    Property: [\r\n\t        \"key\",\r\n\t        \"value\"\r\n\t    ],\r\n\t    PropertyDefinition: [\r\n\t        \"key\",\r\n\t        \"value\"\r\n\t    ],\r\n\t    RestElement: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    ReturnStatement: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    SequenceExpression: [\r\n\t        \"expressions\"\r\n\t    ],\r\n\t    SpreadElement: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    StaticBlock: [\r\n\t        \"body\"\r\n\t    ],\r\n\t    Super: [],\r\n\t    SwitchCase: [\r\n\t        \"test\",\r\n\t        \"consequent\"\r\n\t    ],\r\n\t    SwitchStatement: [\r\n\t        \"discriminant\",\r\n\t        \"cases\"\r\n\t    ],\r\n\t    TaggedTemplateExpression: [\r\n\t        \"tag\",\r\n\t        \"quasi\"\r\n\t    ],\r\n\t    TemplateElement: [],\r\n\t    TemplateLiteral: [\r\n\t        \"quasis\",\r\n\t        \"expressions\"\r\n\t    ],\r\n\t    ThisExpression: [],\r\n\t    ThrowStatement: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    TryStatement: [\r\n\t        \"block\",\r\n\t        \"handler\",\r\n\t        \"finalizer\"\r\n\t    ],\r\n\t    UnaryExpression: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    UpdateExpression: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    VariableDeclaration: [\r\n\t        \"declarations\"\r\n\t    ],\r\n\t    VariableDeclarator: [\r\n\t        \"id\",\r\n\t        \"init\"\r\n\t    ],\r\n\t    WhileStatement: [\r\n\t        \"test\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    WithStatement: [\r\n\t        \"object\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    YieldExpression: [\r\n\t        \"argument\"\r\n\t    ]\r\n\t};\r\n\r\n\t// Types.\r\n\tconst NODE_TYPES = Object.keys(KEYS);\r\n\r\n\t// Freeze the keys.\r\n\tfor (const type of NODE_TYPES) {\r\n\t    Object.freeze(KEYS[type]);\r\n\t}\r\n\tObject.freeze(KEYS);\r\n\r\n\t/**\r\n\t * @typedef {import('./visitor-keys.js').VisitorKeys} VisitorKeys\r\n\t */\r\n\r\n\t// List to ignore keys.\r\n\tconst KEY_BLACKLIST = new Set([\r\n\t    \"parent\",\r\n\t    \"leadingComments\",\r\n\t    \"trailingComments\"\r\n\t]);\r\n\r\n\t/**\r\n\t * Check whether a given key should be used or not.\r\n\t * @param {string} key The key to check.\r\n\t * @returns {boolean} `true` if the key should be used.\r\n\t */\r\n\tfunction filterKey(key) {\r\n\t    return !KEY_BLACKLIST.has(key) && key[0] !== \"_\";\r\n\t}\r\n\r\n\t/**\r\n\t * Get visitor keys of a given node.\r\n\t * @param {object} node The AST node to get keys.\r\n\t * @returns {readonly string[]} Visitor keys of the node.\r\n\t */\r\n\tfunction getKeys(node) {\r\n\t    return Object.keys(node).filter(filterKey);\r\n\t}\r\n\r\n\t// Disable valid-jsdoc rule because it reports syntax error on the type of @returns.\r\n\t// eslint-disable-next-line valid-jsdoc\r\n\t/**\r\n\t * Make the union set with `KEYS` and given keys.\r\n\t * @param {VisitorKeys} additionalKeys The additional keys.\r\n\t * @returns {VisitorKeys} The union set.\r\n\t */\r\n\tfunction unionWith(additionalKeys) {\r\n\t    const retv = /** @type {{\r\n\t        [type: string]: ReadonlyArray<string>\r\n\t    }} */ (Object.assign({}, KEYS));\r\n\r\n\t    for (const type of Object.keys(additionalKeys)) {\r\n\t        if (Object.prototype.hasOwnProperty.call(retv, type)) {\r\n\t            const keys = new Set(additionalKeys[type]);\r\n\r\n\t            for (const key of retv[type]) {\r\n\t                keys.add(key);\r\n\t            }\r\n\r\n\t            retv[type] = Object.freeze(Array.from(keys));\r\n\t        } else {\r\n\t            retv[type] = Object.freeze(Array.from(additionalKeys[type]));\r\n\t        }\r\n\t    }\r\n\r\n\t    return Object.freeze(retv);\r\n\t}\r\n\r\n\treturn  {\r\n\t  KEYS,\r\n\t  getKeys,\r\n\t  unionWith\r\n\t};\r\n\r\n});\ndefine('skylark-espree/espree',[\n    \"skylark-acorn\",\n    \"skylark-acorn/plugins/jsx\",\n    \"./lib/espree\",\n    \"./lib/version\",\n    \"./lib/options\",\n    \"./eslint-visitor-keys\"\n],function(\n    acorn,\n    jsx,\n    espree,\n    espreeVersion,\n    options,\n    visitorKeys\n){\n\n\n    /**\n     * @fileoverview Main Espree file that converts Acorn into Esprima output.\n     *\n     * This file contains code from the following MIT-licensed projects:\n     * 1. Acorn\n     * 2. Babylon\n     * 3. Babel-ESLint\n     *\n     * This file also contains code from Esprima, which is BSD licensed.\n     *\n     * Acorn is Copyright 2012-2015 Acorn Contributors (https://github.com/marijnh/acorn/blob/master/AUTHORS)\n     * Babylon is Copyright 2014-2015 various contributors (https://github.com/babel/babel/blob/master/packages/babylon/AUTHORS)\n     * Babel-ESLint is Copyright 2014-2015 Sebastian McKenzie <sebmck@gmail.com>\n     *\n     * Redistribution and use in source and binary forms, with or without\n     * modification, are permitted provided that the following conditions are met:\n     *\n     * * Redistributions of source code must retain the above copyright\n     *   notice, this list of conditions and the following disclaimer.\n     * * Redistributions in binary form must reproduce the above copyright\n     *   notice, this list of conditions and the following disclaimer in the\n     *   documentation and/or other materials provided with the distribution.\n     *\n     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n     * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n     * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n     * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n     * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n     * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n     * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n     *\n     * Esprima is Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.\n     *\n     * Redistribution and use in source and binary forms, with or without\n     * modification, are permitted provided that the following conditions are met:\n     *\n     *   * Redistributions of source code must retain the above copyright\n     *     notice, this list of conditions and the following disclaimer.\n     *   * Redistributions in binary form must reproduce the above copyright\n     *     notice, this list of conditions and the following disclaimer in the\n     *     documentation and/or other materials provided with the distribution.\n     *\n     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n     * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n     * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n     * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n     * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n     * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n     * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n     */\n    /* eslint no-undefined:0, no-use-before-define: 0 */\n\n    const  { getLatestEcmaVersion, getSupportedEcmaVersions } = options;\n\n\n    // To initialize lazily.\n    const parsers = {\n        _regular: null,\n        _jsx: null,\n\n        get regular() {\n            if (this._regular === null) {\n                this._regular = acorn.Parser.extend(espree());\n            }\n            return this._regular;\n        },\n\n        get jsx() {\n            if (this._jsx === null) {\n                this._jsx = acorn.Parser.extend(jsx(), espree());\n            }\n            return this._jsx;\n        },\n\n        get(options) {\n            const useJsx = Boolean(\n                options &&\n                options.ecmaFeatures &&\n                options.ecmaFeatures.jsx\n            );\n\n            return useJsx ? this.jsx : this.regular;\n        }\n    };\n\n    //------------------------------------------------------------------------------\n    // Tokenizer\n    //------------------------------------------------------------------------------\n\n    /**\n     * Tokenizes the given code.\n     * @param {string} code The code to tokenize.\n     * @param {Object} options Options defining how to tokenize.\n     * @returns {Token[]} An array of tokens.\n     * @throws {SyntaxError} If the input code is invalid.\n     * @private\n     */\n    function tokenize(code, options) {\n        const Parser = parsers.get(options);\n\n        // Ensure to collect tokens.\n        if (!options || options.tokens !== true) {\n            options = Object.assign({}, options, { tokens: true }); // eslint-disable-line no-param-reassign\n        }\n\n        return new Parser(options, code).tokenize();\n    }\n\n    //------------------------------------------------------------------------------\n    // Parser\n    //------------------------------------------------------------------------------\n\n    /**\n     * Parses the given code.\n     * @param {string} code The code to tokenize.\n     * @param {Object} options Options defining how to tokenize.\n     * @returns {ASTNode} The \"Program\" AST node.\n     * @throws {SyntaxError} If the input code is invalid.\n     */\n     function parse(code, options) {\n        const Parser = parsers.get(options);\n\n        return new Parser(options, code).parse();\n    }\n\n    //------------------------------------------------------------------------------\n    // Public\n    //------------------------------------------------------------------------------\n\n    const version = espreeVersion;\n    const name = \"espree\";\n\n    /* istanbul ignore next */\n    const VisitorKeys = (function() {\n        return visitorKeys.KEYS;\n    }());\n\n    // Derive node types from VisitorKeys\n    /* istanbul ignore next */\n    const Syntax = (function() {\n        let key,\n            types = {};\n\n        if (typeof Object.create === \"function\") {\n            types = Object.create(null);\n        }\n\n        for (key in VisitorKeys) {\n            if (Object.hasOwnProperty.call(VisitorKeys, key)) {\n                types[key] = key;\n            }\n        }\n\n        if (typeof Object.freeze === \"function\") {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n\n    const latestEcmaVersion = getLatestEcmaVersion();\n\n    const supportedEcmaVersions = getSupportedEcmaVersions();\n\n    return {\n        tokenize,\n        parse,\n        version,\n        name,\n        VisitorKeys,\n        Syntax,\n        latestEcmaVersion,\n        supportedEcmaVersions\n    }\n\n});\n\ndefine('skylark-espree/main',[\r\n\t\"./espree\"\r\n],function(espree){\r\n\treturn espree;\r\n});\ndefine('skylark-espree', ['skylark-espree/main'], function (main) { return main; });\n\n"]}