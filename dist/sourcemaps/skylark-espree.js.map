{"version":3,"sources":["skylark-espree.js"],"names":["define","XHTMLEntities","quot","amp","apos","lt","gt","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","copy","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","times","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","divide","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","tilde","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","part","exist","empty","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","prop","infin","ang","and","or","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","hexNumber","decimalNumber","acornJsxMap","WeakMap","getJsxTokens","acorn","Parser","acornJsx","get","tt","tokTypes","TokContext","TokenType","tc_oTag","tc_cTag","tc_expr","tokContexts","jsxName","jsxText","beforeExpr","jsxTagStart","startsExpr","jsxTagEnd","updateContext","this","context","push","exprAllowed","prevType","out","pop","slash","curContext","set","getQualifiedJSXName","object","type","name","namespace","property","jsx","options","require","tok","isNewLine","isIdentifierStart","isIdentifierChar","[object Object]","chunkStart","pos","input","length","raise","start","ch","charCodeAt","finishToken","getTokenFromCode","slice","jsx_readEntity","jsx_readNewLine","normalizeCRLF","String","fromCharCode","locations","curLine","lineStart","quote","string","entity","str","count","startPos","substr","test","parseInt","node","startNode","value","keyword","unexpected","next","finishNode","startLoc","jsx_parseIdentifier","allowNamespaces","eat","colon","startNodeAt","jsx_parseNamespacedName","dot","allowNamespacedObjects","newNode","braceL","jsx_parseExpressionContainer","expression","parseExprAtom","lastTokEnd","lastTokEndLoc","finishNodeAt","braceR","jsx_parseEmptyExpression","parseExpression","expect","ellipsis","argument","parseMaybeAssign","eq","jsx_parseAttributeValue","attributes","nodeName","jsx_parseElementName","jsx_parseAttribute","selfClosing","children","openingElement","jsx_parseOpeningElementAt","closingElement","contents","jsx_parseClosingElementAt","jsx_parseElementAt","fragmentOrElement","relational","parseLiteral","refShortHandDefaultPos","jsx_parseText","jsx_parseElement","super","code","jsx_readToken","jsx_readWord","jsx_readString","readToken","b_expr","b_tmpl","plugin","Object","defineProperty","configurable","enumerable","Token","Boolean","EOF","Identifier","PrivateIdentifier","Keyword","Null","Numeric","Punctuator","RegularExpression","Template","JSXIdentifier","JSXText","TokenTranslator","acornTokTypes","_acornTokTypes","_tokens","_curlyBrace","_code","prototype","constructor","token","extra","ecmaVersion","privateId","semi","comma","parenL","parenR","bracketL","question","bracketR","arrow","incDec","starstar","prefix","questionDot","binop","isAssign","end","label","jsxAttrValueToken","num","regexp","regex","flags","pattern","that","tokens","templateTokens","translateTemplateTokens","firstToken","lastTemplateToken","loc","range","convertTemplatePart","eof","backQuote","translate","dollarBraceL","template","invalidTemplate","SUPPORTED_VERSIONS","getLatestEcmaVersion","getSupportedEcmaVersions","normalizeOptions","version","Error","includes","normalizeEcmaVersion","sourceType","normalizeSourceType","ranges","allowReserved","ecmaFeatures","allowReturnOutsideFunction","globalReturn","assign","STATE","Symbol","ESPRIMA_FINISH_NODE","opts","originalSourceType","tokenTranslator","state","comments","comment","impliedStrict","lastToken","templateElements","onToken","onComment","block","text","endLoc","convertAcornCommentToEsprimaComment","args","result","program","parse","body","firstNode","forEach","templateElement","endOffset","tail","column","strict","parseTopLevel","message","getLineInfo","err","SyntaxError","index","lineNumber","line","lastIndexOf","nextToken","generator","KEYS","ArrayExpression","ArrayPattern","ArrowFunctionExpression","AssignmentExpression","AssignmentPattern","AwaitExpression","BinaryExpression","BlockStatement","BreakStatement","CallExpression","CatchClause","ChainExpression","ClassBody","ClassDeclaration","ClassExpression","ConditionalExpression","ContinueStatement","DebuggerStatement","DoWhileStatement","EmptyStatement","ExperimentalRestProperty","ExperimentalSpreadProperty","ExportAllDeclaration","ExportDefaultDeclaration","ExportNamedDeclaration","ExportSpecifier","ExpressionStatement","ForInStatement","ForOfStatement","ForStatement","FunctionDeclaration","FunctionExpression","IfStatement","ImportDeclaration","ImportDefaultSpecifier","ImportExpression","ImportNamespaceSpecifier","ImportSpecifier","JSXAttribute","JSXClosingElement","JSXClosingFragment","JSXElement","JSXEmptyExpression","JSXExpressionContainer","JSXFragment","JSXMemberExpression","JSXNamespacedName","JSXOpeningElement","JSXOpeningFragment","JSXSpreadAttribute","JSXSpreadChild","LabeledStatement","Literal","LogicalExpression","MemberExpression","MetaProperty","MethodDefinition","NewExpression","ObjectExpression","ObjectPattern","Program","Property","PropertyDefinition","RestElement","ReturnStatement","SequenceExpression","SpreadElement","StaticBlock","Super","SwitchCase","SwitchStatement","TaggedTemplateExpression","TemplateElement","TemplateLiteral","ThisExpression","ThrowStatement","TryStatement","UnaryExpression","UpdateExpression","VariableDeclaration","VariableDeclarator","WhileStatement","WithStatement","YieldExpression","NODE_TYPES","keys","freeze","KEY_BLACKLIST","Set","filterKey","key","has","getKeys","filter","unionWith","additionalKeys","retv","hasOwnProperty","call","add","Array","from","espree","espreeVersion","visitorKeys","parsers","_regular","_jsx","regular","extend","useJsx","VisitorKeys","Syntax","types","create","latestEcmaVersion","supportedEcmaVersions","tokenize","main"],"mappings":";;;;;;;g4BAAAA,EAAA,+BAAA,WACA,MAAAC,GACAC,KAAA,IACAC,IAAA,IACAC,KAAA,IACAC,GAAA,IACAC,GAAA,IACAC,KAAA,IACAC,MAAA,IACAC,KAAA,IACAC,MAAA,IACAC,OAAA,IACAC,IAAA,IACAC,OAAA,IACAC,KAAA,IACAC,IAAA,IACAC,KAAA,IACAC,KAAA,IACAC,MAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,KAAA,IACAC,IAAA,IACAC,OAAA,IACAC,KAAA,IACAC,KAAA,IACAC,MAAA,IACAC,MAAA,IACAC,KAAA,IACAC,OAAA,IACAC,MAAA,IACAC,KAAA,IACAC,KAAA,IACAC,MAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,OAAA,IACAC,KAAA,IACAC,MAAA,IACAC,MAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,KAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,KAAA,IACAC,IAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,OAAA,IACAC,KAAA,IACAC,MAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,KAAA,IACAC,OAAA,IACAC,MAAA,IACAC,MAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,OAAA,IACAC,KAAA,IACAC,MAAA,IACAC,MAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IAhFAC,MAAA,IACAC,KAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,KAAA,IACAC,IAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,OAAA,IACAC,KAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,KAAA,IACAC,OAAA,IACAC,MAAA,IACAC,KAAA,IACAC,MAAA,IACAC,MAAA,IACAC,OAAA,IACAC,OAAA,IACAC,KAAA,IACAC,KAAA,IACAC,KAAA,IACAC,MAAA,IACAC,MAAA,IACAC,KAAA,IACAC,MAAA,IACAC,MAAA,IACAC,QAAA,IACAC,KAAA,IACAC,IAAA,IACAC,MAAA,IACAC,KAAA,IACAC,MAAA,IACAC,OAAA,IACAC,GAAA,IACAC,GAAA,IACAC,GAAA,IACAC,QAAA,IACAC,GAAA,IACAC,IAAA,IACAC,MAAA,IACAC,IAAA,IACAC,QAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,MAAA,IACAC,MAAA,IACAC,KAAA,IACAC,MAAA,IACAC,MAAA,IACAC,QAAA,IACAC,KAAA,IACAC,IAAA,IACAC,MAAA,IACAC,KAAA,IACAC,MAAA,IACAC,OAAA,IACAC,GAAA,IACAC,GAAA,IACAC,GAAA,IACAC,QAAA,IACAC,GAAA,IACAC,IAAA,IACAC,OAAA,IACAC,MAAA,IACAC,IAAA,IACAC,QAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,MAAA,IACAC,SAAA,IACAC,MAAA,IACAC,IAAA,IACAC,KAAA,IACAC,KAAA,IACAC,OAAA,IACAC,KAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,MAAA,IACAC,MAAA,IACAC,MAAA,IACAC,MAAA,IACAC,MAAA,IACAC,MAAA,IACAC,MAAA,IACAC,MAAA,IACAC,OAAA,IACAC,OAAA,IACAC,KAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,MAAA,IACAC,OAAA,IACAC,OAAA,IACAC,MAAA,IACAC,MAAA,IACAC,KAAA,IACAC,MAAA,IACAC,OAAA,IACAC,KAAA,IACAC,MAAA,IACAC,QAAA,IACAC,KAAA,IACAC,KAAA,IACAC,KAAA,IACAC,KAAA,IACAC,KAAA,IACAC,MAAA,IACAC,KAAA,IACAC,KAAA,IACAC,KAAA,IACAC,KAAA,IACAC,KAAA,IACAC,OAAA,IACAC,KAAA,IACAC,MAAA,IACAC,MAAA,IACAC,MAAA,IACAC,KAAA,IACAC,MAAA,IACAC,GAAA,IACAC,KAAA,IACAC,IAAA,IACAC,MA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,EAAAqB,YACArB,EAAAqB,WAAA,GAGArB,OAOA5e,EAAA,gCAAA,WAGA,MAFA,SAMAA,EAAA,wCAAA,WAQA,MAAAkgB,GACAC,iBACA,YAEAC,cACA,YAEAC,yBACA,SACA,QAEAC,sBACA,OACA,SAEAC,mBACA,OACA,SAEAC,iBACA,YAEAC,kBACA,OACA,SAEAC,gBACA,QAEAC,gBACA,SAEAC,gBACA,SACA,aAEAC,aACA,QACA,QAEAC,iBACA,cAEAC,WACA,QAEAC,kBACA,KACA,aACA,QAEAC,iBACA,KACA,aACA,QAEAC,uBACA,OACA,aACA,aAEAC,mBACA,SAEAC,qBACAC,kBACA,OACA,QAEAC,kBACAC,0BACA,YAEAC,4BACA,YAEAC,sBACA,WACA,UAEAC,0BACA,eAEAC,wBACA,cACA,aACA,UAEAC,iBACA,WACA,SAEAC,qBACA,cAEAC,gBACA,OACA,QACA,QAEAC,gBACA,OACA,QACA,QAEAC,cACA,OACA,OACA,SACA,QAEAC,qBACA,KACA,SACA,QAEAC,oBACA,KACA,SACA,QAEApJ,cACAqJ,aACA,OACA,aACA,aAEAC,mBACA,aACA,UAEAC,wBACA,SAEAC,kBACA,UAEAC,0BACA,SAEAC,iBACA,WACA,SAEAC,cACA,OACA,SAEAC,mBACA,QAEAC,sBACAC,YACA,iBACA,WACA,kBAEAC,sBACAC,wBACA,cAEAC,aACA,kBACA,WACA,mBAEAzJ,iBACA0J,qBACA,SACA,YAEAC,mBACA,YACA,QAEAC,mBACA,OACA,cAEAC,sBACAC,oBACA,YAEAC,gBACA,cAEA9J,WACA+J,kBACA,QACA,QAEAC,WACAC,mBACA,OACA,SAEAC,kBACA,SACA,YAEAC,cACA,OACA,YAEAC,kBACA,MACA,SAEAC,eACA,SACA,aAEAC,kBACA,cAEAC,eACA,cAEA/K,qBACAgL,SACA,QAEAC,UACA,MACA,SAEAC,oBACA,MACA,SAEAC,aACA,YAEAC,iBACA,YAEAC,oBACA,eAEAC,eACA,YAEAC,aACA,QAEAC,SACAC,YACA,OACA,cAEAC,iBACA,eACA,SAEAC,0BACA,MACA,SAEAC,mBACAC,iBACA,SACA,eAEAC,kBACAC,gBACA,YAEAC,cACA,QACA,UACA,aAEAC,iBACA,YAEAC,kBACA,YAEAC,qBACA,gBAEAC,oBACA,KACA,QAEAC,gBACA,OACA,QAEAC,eACA,SACA,QAEAC,iBACA,aAKAC,EAAAhN,OAAAiN,KAAAtF,GAGA,IAAA,MAAA/N,KAAAoT,EACAhN,OAAAkN,OAAAvF,EAAA/N,IAEAoG,OAAAkN,OAAAvF,GAOA,MAAAwF,EAAA,IAAAC,KACA,SACA,kBACA,qBAQA,SAAAC,EAAAC,GACA,OAAAH,EAAAI,IAAAD,IAAA,MAAAA,EAAA,GAyCA,OACA3F,KAAAA,EACA6F,QAnCA,SAAApR,GACA,OAAA4D,OAAAiN,KAAA7Q,GAAAqR,OAAAJ,IAmCAK,UAzBA,SAAAC,GACA,MAAAC,EAEA5N,OAAAiF,UAAA0C,GAEA,IAAA,MAAA/N,KAAAoG,OAAAiN,KAAAU,GACA,GAAA3N,OAAAuB,UAAAsM,eAAAC,KAAAF,EAAAhU,GAAA,CACA,MAAAqT,EAAA,IAAAG,IAAAO,EAAA/T,IAEA,IAAA,MAAA0T,KAAAM,EAAAhU,GACAqT,EAAAc,IAAAT,GAGAM,EAAAhU,GAAAoG,OAAAkN,OAAAc,MAAAC,KAAAhB,SAEAW,EAAAhU,GAAAoG,OAAAkN,OAAAc,MAAAC,KAAAN,EAAA/T,KAIA,OAAAoG,OAAAkN,OAAAU,OAUAnmB,EAAA,yBACA,gBACA,4BACA,eACA,gBACA,gBACA,yBACA,SACAoQ,EACAmC,EACAkU,EACAC,EACAlU,EACAmU,GA8DA,MAAAjK,qBAAAA,EAAAC,yBAAAA,GAAAnK,EAIAoU,GACAC,SAAA,KACAC,KAAA,KAEAC,cAIA,OAHA,OAAAxV,KAAAsV,WACAtV,KAAAsV,SAAAzW,EAAAC,OAAA2W,OAAAP,MAEAlV,KAAAsV,UAGAtU,UAIA,OAHA,OAAAhB,KAAAuV,OACAvV,KAAAuV,KAAA1W,EAAAC,OAAA2W,OAAAzU,IAAAkU,MAEAlV,KAAAuV,MAGAhU,IAAAN,GACA,MAAAyU,EAAArO,QACApG,GACAA,EAAA6K,cACA7K,EAAA6K,aAAA9K,KAGA,OAAA0U,EAAA1V,KAAAgB,IAAAhB,KAAAwV,UAgDA,MAAAlK,EAAA6J,EAIAQ,EACAP,EAAAzG,KAKAiH,EAAA,WACA,IAAAtB,EACAuB,KAMA,IAAAvB,IAJA,mBAAAtN,OAAA8O,SACAD,EAAA7O,OAAA8O,OAAA,OAGAH,EACA3O,OAAA6N,eAAAC,KAAAa,EAAArB,KACAuB,EAAAvB,GAAAA,GAQA,MAJA,mBAAAtN,OAAAkN,QACAlN,OAAAkN,OAAA2B,GAGAA,EAlBA,GAsBAE,EAAA5K,IAEA6K,EAAA5K,IAEA,OACA6K,SArEA,SAAAzP,EAAAvF,GACA,MAAAnC,EAAAuW,EAAArW,IAAAiC,GAGAA,IAAA,IAAAA,EAAAmJ,SACAnJ,EAAA+F,OAAAiF,UAAAhL,GAAAmJ,QAAA,KAGA,OAAA,IAAAtL,EAAAmC,EAAAuF,GAAAyP,YA8DA1I,MAhDA,SAAA/G,EAAAvF,GAGA,OAAA,IAFAoU,EAAArW,IAAAiC,GAEA,CAAAA,EAAAuF,GAAA+G,SA8CAjC,QAAAA,EACAzK,KAvCA,SAwCA8U,YAAAA,EACAC,OAAAA,EACAG,kBAAAA,EACAC,sBAAAA,KAKAvnB,EAAA,uBACA,YACA,SAAAymB,GACA,OAAAA,IAEAzmB,EAAA,kBAAA,uBAAA,SAAAynB,GAAA,OAAAA","file":"../skylark-espree.js","sourcesContent":["define('skylark-acorn/plugins/jsx',[],function(){\r\n  const XHTMLEntities = {\r\n    quot: '\\u0022',\r\n    amp: '&',\r\n    apos: '\\u0027',\r\n    lt: '<',\r\n    gt: '>',\r\n    nbsp: '\\u00A0',\r\n    iexcl: '\\u00A1',\r\n    cent: '\\u00A2',\r\n    pound: '\\u00A3',\r\n    curren: '\\u00A4',\r\n    yen: '\\u00A5',\r\n    brvbar: '\\u00A6',\r\n    sect: '\\u00A7',\r\n    uml: '\\u00A8',\r\n    copy: '\\u00A9',\r\n    ordf: '\\u00AA',\r\n    laquo: '\\u00AB',\r\n    not: '\\u00AC',\r\n    shy: '\\u00AD',\r\n    reg: '\\u00AE',\r\n    macr: '\\u00AF',\r\n    deg: '\\u00B0',\r\n    plusmn: '\\u00B1',\r\n    sup2: '\\u00B2',\r\n    sup3: '\\u00B3',\r\n    acute: '\\u00B4',\r\n    micro: '\\u00B5',\r\n    para: '\\u00B6',\r\n    middot: '\\u00B7',\r\n    cedil: '\\u00B8',\r\n    sup1: '\\u00B9',\r\n    ordm: '\\u00BA',\r\n    raquo: '\\u00BB',\r\n    frac14: '\\u00BC',\r\n    frac12: '\\u00BD',\r\n    frac34: '\\u00BE',\r\n    iquest: '\\u00BF',\r\n    Agrave: '\\u00C0',\r\n    Aacute: '\\u00C1',\r\n    Acirc: '\\u00C2',\r\n    Atilde: '\\u00C3',\r\n    Auml: '\\u00C4',\r\n    Aring: '\\u00C5',\r\n    AElig: '\\u00C6',\r\n    Ccedil: '\\u00C7',\r\n    Egrave: '\\u00C8',\r\n    Eacute: '\\u00C9',\r\n    Ecirc: '\\u00CA',\r\n    Euml: '\\u00CB',\r\n    Igrave: '\\u00CC',\r\n    Iacute: '\\u00CD',\r\n    Icirc: '\\u00CE',\r\n    Iuml: '\\u00CF',\r\n    ETH: '\\u00D0',\r\n    Ntilde: '\\u00D1',\r\n    Ograve: '\\u00D2',\r\n    Oacute: '\\u00D3',\r\n    Ocirc: '\\u00D4',\r\n    Otilde: '\\u00D5',\r\n    Ouml: '\\u00D6',\r\n    times: '\\u00D7',\r\n    Oslash: '\\u00D8',\r\n    Ugrave: '\\u00D9',\r\n    Uacute: '\\u00DA',\r\n    Ucirc: '\\u00DB',\r\n    Uuml: '\\u00DC',\r\n    Yacute: '\\u00DD',\r\n    THORN: '\\u00DE',\r\n    szlig: '\\u00DF',\r\n    agrave: '\\u00E0',\r\n    aacute: '\\u00E1',\r\n    acirc: '\\u00E2',\r\n    atilde: '\\u00E3',\r\n    auml: '\\u00E4',\r\n    aring: '\\u00E5',\r\n    aelig: '\\u00E6',\r\n    ccedil: '\\u00E7',\r\n    egrave: '\\u00E8',\r\n    eacute: '\\u00E9',\r\n    ecirc: '\\u00EA',\r\n    euml: '\\u00EB',\r\n    igrave: '\\u00EC',\r\n    iacute: '\\u00ED',\r\n    icirc: '\\u00EE',\r\n    iuml: '\\u00EF',\r\n    eth: '\\u00F0',\r\n    ntilde: '\\u00F1',\r\n    ograve: '\\u00F2',\r\n    oacute: '\\u00F3',\r\n    ocirc: '\\u00F4',\r\n    otilde: '\\u00F5',\r\n    ouml: '\\u00F6',\r\n    divide: '\\u00F7',\r\n    oslash: '\\u00F8',\r\n    ugrave: '\\u00F9',\r\n    uacute: '\\u00FA',\r\n    ucirc: '\\u00FB',\r\n    uuml: '\\u00FC',\r\n    yacute: '\\u00FD',\r\n    thorn: '\\u00FE',\r\n    yuml: '\\u00FF',\r\n    OElig: '\\u0152',\r\n    oelig: '\\u0153',\r\n    Scaron: '\\u0160',\r\n    scaron: '\\u0161',\r\n    Yuml: '\\u0178',\r\n    fnof: '\\u0192',\r\n    circ: '\\u02C6',\r\n    tilde: '\\u02DC',\r\n    Alpha: '\\u0391',\r\n    Beta: '\\u0392',\r\n    Gamma: '\\u0393',\r\n    Delta: '\\u0394',\r\n    Epsilon: '\\u0395',\r\n    Zeta: '\\u0396',\r\n    Eta: '\\u0397',\r\n    Theta: '\\u0398',\r\n    Iota: '\\u0399',\r\n    Kappa: '\\u039A',\r\n    Lambda: '\\u039B',\r\n    Mu: '\\u039C',\r\n    Nu: '\\u039D',\r\n    Xi: '\\u039E',\r\n    Omicron: '\\u039F',\r\n    Pi: '\\u03A0',\r\n    Rho: '\\u03A1',\r\n    Sigma: '\\u03A3',\r\n    Tau: '\\u03A4',\r\n    Upsilon: '\\u03A5',\r\n    Phi: '\\u03A6',\r\n    Chi: '\\u03A7',\r\n    Psi: '\\u03A8',\r\n    Omega: '\\u03A9',\r\n    alpha: '\\u03B1',\r\n    beta: '\\u03B2',\r\n    gamma: '\\u03B3',\r\n    delta: '\\u03B4',\r\n    epsilon: '\\u03B5',\r\n    zeta: '\\u03B6',\r\n    eta: '\\u03B7',\r\n    theta: '\\u03B8',\r\n    iota: '\\u03B9',\r\n    kappa: '\\u03BA',\r\n    lambda: '\\u03BB',\r\n    mu: '\\u03BC',\r\n    nu: '\\u03BD',\r\n    xi: '\\u03BE',\r\n    omicron: '\\u03BF',\r\n    pi: '\\u03C0',\r\n    rho: '\\u03C1',\r\n    sigmaf: '\\u03C2',\r\n    sigma: '\\u03C3',\r\n    tau: '\\u03C4',\r\n    upsilon: '\\u03C5',\r\n    phi: '\\u03C6',\r\n    chi: '\\u03C7',\r\n    psi: '\\u03C8',\r\n    omega: '\\u03C9',\r\n    thetasym: '\\u03D1',\r\n    upsih: '\\u03D2',\r\n    piv: '\\u03D6',\r\n    ensp: '\\u2002',\r\n    emsp: '\\u2003',\r\n    thinsp: '\\u2009',\r\n    zwnj: '\\u200C',\r\n    zwj: '\\u200D',\r\n    lrm: '\\u200E',\r\n    rlm: '\\u200F',\r\n    ndash: '\\u2013',\r\n    mdash: '\\u2014',\r\n    lsquo: '\\u2018',\r\n    rsquo: '\\u2019',\r\n    sbquo: '\\u201A',\r\n    ldquo: '\\u201C',\r\n    rdquo: '\\u201D',\r\n    bdquo: '\\u201E',\r\n    dagger: '\\u2020',\r\n    Dagger: '\\u2021',\r\n    bull: '\\u2022',\r\n    hellip: '\\u2026',\r\n    permil: '\\u2030',\r\n    prime: '\\u2032',\r\n    Prime: '\\u2033',\r\n    lsaquo: '\\u2039',\r\n    rsaquo: '\\u203A',\r\n    oline: '\\u203E',\r\n    frasl: '\\u2044',\r\n    euro: '\\u20AC',\r\n    image: '\\u2111',\r\n    weierp: '\\u2118',\r\n    real: '\\u211C',\r\n    trade: '\\u2122',\r\n    alefsym: '\\u2135',\r\n    larr: '\\u2190',\r\n    uarr: '\\u2191',\r\n    rarr: '\\u2192',\r\n    darr: '\\u2193',\r\n    harr: '\\u2194',\r\n    crarr: '\\u21B5',\r\n    lArr: '\\u21D0',\r\n    uArr: '\\u21D1',\r\n    rArr: '\\u21D2',\r\n    dArr: '\\u21D3',\r\n    hArr: '\\u21D4',\r\n    forall: '\\u2200',\r\n    part: '\\u2202',\r\n    exist: '\\u2203',\r\n    empty: '\\u2205',\r\n    nabla: '\\u2207',\r\n    isin: '\\u2208',\r\n    notin: '\\u2209',\r\n    ni: '\\u220B',\r\n    prod: '\\u220F',\r\n    sum: '\\u2211',\r\n    minus: '\\u2212',\r\n    lowast: '\\u2217',\r\n    radic: '\\u221A',\r\n    prop: '\\u221D',\r\n    infin: '\\u221E',\r\n    ang: '\\u2220',\r\n    and: '\\u2227',\r\n    or: '\\u2228',\r\n    cap: '\\u2229',\r\n    cup: '\\u222A',\r\n    'int': '\\u222B',\r\n    there4: '\\u2234',\r\n    sim: '\\u223C',\r\n    cong: '\\u2245',\r\n    asymp: '\\u2248',\r\n    ne: '\\u2260',\r\n    equiv: '\\u2261',\r\n    le: '\\u2264',\r\n    ge: '\\u2265',\r\n    sub: '\\u2282',\r\n    sup: '\\u2283',\r\n    nsub: '\\u2284',\r\n    sube: '\\u2286',\r\n    supe: '\\u2287',\r\n    oplus: '\\u2295',\r\n    otimes: '\\u2297',\r\n    perp: '\\u22A5',\r\n    sdot: '\\u22C5',\r\n    lceil: '\\u2308',\r\n    rceil: '\\u2309',\r\n    lfloor: '\\u230A',\r\n    rfloor: '\\u230B',\r\n    lang: '\\u2329',\r\n    rang: '\\u232A',\r\n    loz: '\\u25CA',\r\n    spades: '\\u2660',\r\n    clubs: '\\u2663',\r\n    hearts: '\\u2665',\r\n    diams: '\\u2666'\r\n  };\r\n\r\n  const hexNumber = /^[\\da-fA-F]+$/;\r\n  const decimalNumber = /^\\d+$/;\r\n\r\n  // The map to `acorn-jsx` tokens from `acorn` namespace objects.\r\n  const acornJsxMap = new WeakMap();\r\n\r\n  // Get the original tokens for the given `acorn` namespace object.\r\n  function getJsxTokens(acorn) {\r\n    acorn = acorn.Parser.acorn || acorn;\r\n    let acornJsx = acornJsxMap.get(acorn);\r\n    if (!acornJsx) {\r\n      const tt = acorn.tokTypes;\r\n      const TokContext = acorn.TokContext;\r\n      const TokenType = acorn.TokenType;\r\n      const tc_oTag = new TokContext('<tag', false);\r\n      const tc_cTag = new TokContext('</tag', false);\r\n      const tc_expr = new TokContext('<tag>...</tag>', true, true);\r\n      const tokContexts = {\r\n        tc_oTag: tc_oTag,\r\n        tc_cTag: tc_cTag,\r\n        tc_expr: tc_expr\r\n      };\r\n      const tokTypes = {\r\n        jsxName: new TokenType('jsxName'),\r\n        jsxText: new TokenType('jsxText', {beforeExpr: true}),\r\n        jsxTagStart: new TokenType('jsxTagStart', {startsExpr: true}),\r\n        jsxTagEnd: new TokenType('jsxTagEnd')\r\n      };\r\n\r\n      tokTypes.jsxTagStart.updateContext = function() {\r\n        this.context.push(tc_expr); // treat as beginning of JSX expression\r\n        this.context.push(tc_oTag); // start opening tag context\r\n        this.exprAllowed = false;\r\n      };\r\n      tokTypes.jsxTagEnd.updateContext = function(prevType) {\r\n        let out = this.context.pop();\r\n        if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {\r\n          this.context.pop();\r\n          this.exprAllowed = this.curContext() === tc_expr;\r\n        } else {\r\n          this.exprAllowed = true;\r\n        }\r\n      };\r\n\r\n      acornJsx = { tokContexts: tokContexts, tokTypes: tokTypes };\r\n      acornJsxMap.set(acorn, acornJsx);\r\n    }\r\n\r\n    return acornJsx;\r\n  }\r\n\r\n  // Transforms JSX element name to string.\r\n\r\n  function getQualifiedJSXName(object) {\r\n    if (!object)\r\n      return object;\r\n\r\n    if (object.type === 'JSXIdentifier')\r\n      return object.name;\r\n\r\n    if (object.type === 'JSXNamespacedName')\r\n      return object.namespace.name + ':' + object.name.name;\r\n\r\n    if (object.type === 'JSXMemberExpression')\r\n      return getQualifiedJSXName(object.object) + '.' +\r\n      getQualifiedJSXName(object.property);\r\n  }\r\n\r\n  function jsx(options) {\r\n    options = options || {};\r\n    return function(Parser) {\r\n      return plugin({\r\n        allowNamespaces: options.allowNamespaces !== false,\r\n        allowNamespacedObjects: !!options.allowNamespacedObjects\r\n      }, Parser);\r\n    };\r\n  };\r\n\r\n  // This is `tokTypes` of the peer dep.\r\n  // This can be different instances from the actual `tokTypes` this plugin uses.\r\n  Object.defineProperty(jsx, \"tokTypes\", {\r\n    get: function get_tokTypes() {\r\n      return getJsxTokens(require(\"acorn\")).tokTypes;\r\n    },\r\n    configurable: true,\r\n    enumerable: true\r\n  });\r\n\r\n  function plugin(options, Parser) {\r\n    const acorn = Parser.acorn || require(\"acorn\");\r\n    const acornJsx = getJsxTokens(acorn);\r\n    const tt = acorn.tokTypes;\r\n    const tok = acornJsx.tokTypes;\r\n    const tokContexts = acorn.tokContexts;\r\n    const tc_oTag = acornJsx.tokContexts.tc_oTag;\r\n    const tc_cTag = acornJsx.tokContexts.tc_cTag;\r\n    const tc_expr = acornJsx.tokContexts.tc_expr;\r\n    const isNewLine = acorn.isNewLine;\r\n    const isIdentifierStart = acorn.isIdentifierStart;\r\n    const isIdentifierChar = acorn.isIdentifierChar;\r\n\r\n    return class extends Parser {\r\n      // Expose actual `tokTypes` and `tokContexts` to other plugins.\r\n      static get acornJsx() {\r\n        return acornJsx;\r\n      }\r\n\r\n      // Reads inline JSX contents token.\r\n      jsx_readToken() {\r\n        let out = '', chunkStart = this.pos;\r\n        for (;;) {\r\n          if (this.pos >= this.input.length)\r\n            this.raise(this.start, 'Unterminated JSX contents');\r\n          let ch = this.input.charCodeAt(this.pos);\r\n\r\n          switch (ch) {\r\n          case 60: // '<'\r\n          case 123: // '{'\r\n            if (this.pos === this.start) {\r\n              if (ch === 60 && this.exprAllowed) {\r\n                ++this.pos;\r\n                return this.finishToken(tok.jsxTagStart);\r\n              }\r\n              return this.getTokenFromCode(ch);\r\n            }\r\n            out += this.input.slice(chunkStart, this.pos);\r\n            return this.finishToken(tok.jsxText, out);\r\n\r\n          case 38: // '&'\r\n            out += this.input.slice(chunkStart, this.pos);\r\n            out += this.jsx_readEntity();\r\n            chunkStart = this.pos;\r\n            break;\r\n\r\n          case 62: // '>'\r\n          case 125: // '}'\r\n            this.raise(\r\n              this.pos,\r\n              \"Unexpected token `\" + this.input[this.pos] + \"`. Did you mean `\" +\r\n                (ch === 62 ? \"&gt;\" : \"&rbrace;\") + \"` or \" + \"`{\\\"\" + this.input[this.pos] + \"\\\"}\" + \"`?\"\r\n            );\r\n\r\n          default:\r\n            if (isNewLine(ch)) {\r\n              out += this.input.slice(chunkStart, this.pos);\r\n              out += this.jsx_readNewLine(true);\r\n              chunkStart = this.pos;\r\n            } else {\r\n              ++this.pos;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      jsx_readNewLine(normalizeCRLF) {\r\n        let ch = this.input.charCodeAt(this.pos);\r\n        let out;\r\n        ++this.pos;\r\n        if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {\r\n          ++this.pos;\r\n          out = normalizeCRLF ? '\\n' : '\\r\\n';\r\n        } else {\r\n          out = String.fromCharCode(ch);\r\n        }\r\n        if (this.options.locations) {\r\n          ++this.curLine;\r\n          this.lineStart = this.pos;\r\n        }\r\n\r\n        return out;\r\n      }\r\n\r\n      jsx_readString(quote) {\r\n        let out = '', chunkStart = ++this.pos;\r\n        for (;;) {\r\n          if (this.pos >= this.input.length)\r\n            this.raise(this.start, 'Unterminated string constant');\r\n          let ch = this.input.charCodeAt(this.pos);\r\n          if (ch === quote) break;\r\n          if (ch === 38) { // '&'\r\n            out += this.input.slice(chunkStart, this.pos);\r\n            out += this.jsx_readEntity();\r\n            chunkStart = this.pos;\r\n          } else if (isNewLine(ch)) {\r\n            out += this.input.slice(chunkStart, this.pos);\r\n            out += this.jsx_readNewLine(false);\r\n            chunkStart = this.pos;\r\n          } else {\r\n            ++this.pos;\r\n          }\r\n        }\r\n        out += this.input.slice(chunkStart, this.pos++);\r\n        return this.finishToken(tt.string, out);\r\n      }\r\n\r\n      jsx_readEntity() {\r\n        let str = '', count = 0, entity;\r\n        let ch = this.input[this.pos];\r\n        if (ch !== '&')\r\n          this.raise(this.pos, 'Entity must start with an ampersand');\r\n        let startPos = ++this.pos;\r\n        while (this.pos < this.input.length && count++ < 10) {\r\n          ch = this.input[this.pos++];\r\n          if (ch === ';') {\r\n            if (str[0] === '#') {\r\n              if (str[1] === 'x') {\r\n                str = str.substr(2);\r\n                if (hexNumber.test(str))\r\n                  entity = String.fromCharCode(parseInt(str, 16));\r\n              } else {\r\n                str = str.substr(1);\r\n                if (decimalNumber.test(str))\r\n                  entity = String.fromCharCode(parseInt(str, 10));\r\n              }\r\n            } else {\r\n              entity = XHTMLEntities[str];\r\n            }\r\n            break;\r\n          }\r\n          str += ch;\r\n        }\r\n        if (!entity) {\r\n          this.pos = startPos;\r\n          return '&';\r\n        }\r\n        return entity;\r\n      }\r\n\r\n      // Read a JSX identifier (valid tag or attribute name).\r\n      //\r\n      // Optimized version since JSX identifiers can't contain\r\n      // escape characters and so can be read as single slice.\r\n      // Also assumes that first character was already checked\r\n      // by isIdentifierStart in readToken.\r\n\r\n      jsx_readWord() {\r\n        let ch, start = this.pos;\r\n        do {\r\n          ch = this.input.charCodeAt(++this.pos);\r\n        } while (isIdentifierChar(ch) || ch === 45); // '-'\r\n        return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));\r\n      }\r\n\r\n      // Parse next token as JSX identifier\r\n\r\n      jsx_parseIdentifier() {\r\n        let node = this.startNode();\r\n        if (this.type === tok.jsxName)\r\n          node.name = this.value;\r\n        else if (this.type.keyword)\r\n          node.name = this.type.keyword;\r\n        else\r\n          this.unexpected();\r\n        this.next();\r\n        return this.finishNode(node, 'JSXIdentifier');\r\n      }\r\n\r\n      // Parse namespaced identifier.\r\n\r\n      jsx_parseNamespacedName() {\r\n        let startPos = this.start, startLoc = this.startLoc;\r\n        let name = this.jsx_parseIdentifier();\r\n        if (!options.allowNamespaces || !this.eat(tt.colon)) return name;\r\n        var node = this.startNodeAt(startPos, startLoc);\r\n        node.namespace = name;\r\n        node.name = this.jsx_parseIdentifier();\r\n        return this.finishNode(node, 'JSXNamespacedName');\r\n      }\r\n\r\n      // Parses element name in any form - namespaced, member\r\n      // or single identifier.\r\n\r\n      jsx_parseElementName() {\r\n        if (this.type === tok.jsxTagEnd) return '';\r\n        let startPos = this.start, startLoc = this.startLoc;\r\n        let node = this.jsx_parseNamespacedName();\r\n        if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !options.allowNamespacedObjects) {\r\n          this.unexpected();\r\n        }\r\n        while (this.eat(tt.dot)) {\r\n          let newNode = this.startNodeAt(startPos, startLoc);\r\n          newNode.object = node;\r\n          newNode.property = this.jsx_parseIdentifier();\r\n          node = this.finishNode(newNode, 'JSXMemberExpression');\r\n        }\r\n        return node;\r\n      }\r\n\r\n      // Parses any type of JSX attribute value.\r\n\r\n      jsx_parseAttributeValue() {\r\n        switch (this.type) {\r\n        case tt.braceL:\r\n          let node = this.jsx_parseExpressionContainer();\r\n          if (node.expression.type === 'JSXEmptyExpression')\r\n            this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');\r\n          return node;\r\n\r\n        case tok.jsxTagStart:\r\n        case tt.string:\r\n          return this.parseExprAtom();\r\n\r\n        default:\r\n          this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');\r\n        }\r\n      }\r\n\r\n      // JSXEmptyExpression is unique type since it doesn't actually parse anything,\r\n      // and so it should start at the end of last read token (left brace) and finish\r\n      // at the beginning of the next one (right brace).\r\n\r\n      jsx_parseEmptyExpression() {\r\n        let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\r\n        return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);\r\n      }\r\n\r\n      // Parses JSX expression enclosed into curly brackets.\r\n\r\n      jsx_parseExpressionContainer() {\r\n        let node = this.startNode();\r\n        this.next();\r\n        node.expression = this.type === tt.braceR\r\n          ? this.jsx_parseEmptyExpression()\r\n          : this.parseExpression();\r\n        this.expect(tt.braceR);\r\n        return this.finishNode(node, 'JSXExpressionContainer');\r\n      }\r\n\r\n      // Parses following JSX attribute name-value pair.\r\n\r\n      jsx_parseAttribute() {\r\n        let node = this.startNode();\r\n        if (this.eat(tt.braceL)) {\r\n          this.expect(tt.ellipsis);\r\n          node.argument = this.parseMaybeAssign();\r\n          this.expect(tt.braceR);\r\n          return this.finishNode(node, 'JSXSpreadAttribute');\r\n        }\r\n        node.name = this.jsx_parseNamespacedName();\r\n        node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;\r\n        return this.finishNode(node, 'JSXAttribute');\r\n      }\r\n\r\n      // Parses JSX opening tag starting after '<'.\r\n\r\n      jsx_parseOpeningElementAt(startPos, startLoc) {\r\n        let node = this.startNodeAt(startPos, startLoc);\r\n        node.attributes = [];\r\n        let nodeName = this.jsx_parseElementName();\r\n        if (nodeName) node.name = nodeName;\r\n        while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)\r\n          node.attributes.push(this.jsx_parseAttribute());\r\n        node.selfClosing = this.eat(tt.slash);\r\n        this.expect(tok.jsxTagEnd);\r\n        return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');\r\n      }\r\n\r\n      // Parses JSX closing tag starting after '</'.\r\n\r\n      jsx_parseClosingElementAt(startPos, startLoc) {\r\n        let node = this.startNodeAt(startPos, startLoc);\r\n        let nodeName = this.jsx_parseElementName();\r\n        if (nodeName) node.name = nodeName;\r\n        this.expect(tok.jsxTagEnd);\r\n        return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');\r\n      }\r\n\r\n      // Parses entire JSX element, including it's opening tag\r\n      // (starting after '<'), attributes, contents and closing tag.\r\n\r\n      jsx_parseElementAt(startPos, startLoc) {\r\n        let node = this.startNodeAt(startPos, startLoc);\r\n        let children = [];\r\n        let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);\r\n        let closingElement = null;\r\n\r\n        if (!openingElement.selfClosing) {\r\n          contents: for (;;) {\r\n            switch (this.type) {\r\n            case tok.jsxTagStart:\r\n              startPos = this.start; startLoc = this.startLoc;\r\n              this.next();\r\n              if (this.eat(tt.slash)) {\r\n                closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);\r\n                break contents;\r\n              }\r\n              children.push(this.jsx_parseElementAt(startPos, startLoc));\r\n              break;\r\n\r\n            case tok.jsxText:\r\n              children.push(this.parseExprAtom());\r\n              break;\r\n\r\n            case tt.braceL:\r\n              children.push(this.jsx_parseExpressionContainer());\r\n              break;\r\n\r\n            default:\r\n              this.unexpected();\r\n            }\r\n          }\r\n          if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\r\n            this.raise(\r\n              closingElement.start,\r\n              'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');\r\n          }\r\n        }\r\n        let fragmentOrElement = openingElement.name ? 'Element' : 'Fragment';\r\n\r\n        node['opening' + fragmentOrElement] = openingElement;\r\n        node['closing' + fragmentOrElement] = closingElement;\r\n        node.children = children;\r\n        if (this.type === tt.relational && this.value === \"<\") {\r\n          this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\r\n        }\r\n        return this.finishNode(node, 'JSX' + fragmentOrElement);\r\n      }\r\n\r\n      // Parse JSX text\r\n\r\n      jsx_parseText() {\r\n        let node = this.parseLiteral(this.value);\r\n        node.type = \"JSXText\";\r\n        return node;\r\n      }\r\n\r\n      // Parses entire JSX element from current position.\r\n\r\n      jsx_parseElement() {\r\n        let startPos = this.start, startLoc = this.startLoc;\r\n        this.next();\r\n        return this.jsx_parseElementAt(startPos, startLoc);\r\n      }\r\n\r\n      parseExprAtom(refShortHandDefaultPos) {\r\n        if (this.type === tok.jsxText)\r\n          return this.jsx_parseText();\r\n        else if (this.type === tok.jsxTagStart)\r\n          return this.jsx_parseElement();\r\n        else\r\n          return super.parseExprAtom(refShortHandDefaultPos);\r\n      }\r\n\r\n      readToken(code) {\r\n        let context = this.curContext();\r\n\r\n        if (context === tc_expr) return this.jsx_readToken();\r\n\r\n        if (context === tc_oTag || context === tc_cTag) {\r\n          if (isIdentifierStart(code)) return this.jsx_readWord();\r\n\r\n          if (code == 62) {\r\n            ++this.pos;\r\n            return this.finishToken(tok.jsxTagEnd);\r\n          }\r\n\r\n          if ((code === 34 || code === 39) && context == tc_oTag)\r\n            return this.jsx_readString(code);\r\n        }\r\n\r\n        if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {\r\n          ++this.pos;\r\n          return this.finishToken(tok.jsxTagStart);\r\n        }\r\n        return super.readToken(code);\r\n      }\r\n\r\n      updateContext(prevType) {\r\n        if (this.type == tt.braceL) {\r\n          var curContext = this.curContext();\r\n          if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);\r\n          else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);\r\n          else super.updateContext(prevType);\r\n          this.exprAllowed = true;\r\n        } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {\r\n          this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\r\n          this.context.push(tc_cTag); // reconsider as closing tag context\r\n          this.exprAllowed = false;\r\n        } else {\r\n          return super.updateContext(prevType);\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  return jsx;\r\n});\ndefine('skylark-espree/lib/token-translator',[],function(){\n\n    /**\n     * @fileoverview Translates tokens between Acorn format and Esprima format.\n     * @author Nicholas C. Zakas\n     */\n    /* eslint no-underscore-dangle: 0 */\n\n    //------------------------------------------------------------------------------\n    // Requirements\n    //------------------------------------------------------------------------------\n\n    // none!\n\n    //------------------------------------------------------------------------------\n    // Private\n    //------------------------------------------------------------------------------\n\n\n    // Esprima Token Types\n    const Token = {\n        Boolean: \"Boolean\",\n        EOF: \"<end>\",\n        Identifier: \"Identifier\",\n        PrivateIdentifier: \"PrivateIdentifier\",\n        Keyword: \"Keyword\",\n        Null: \"Null\",\n        Numeric: \"Numeric\",\n        Punctuator: \"Punctuator\",\n        String: \"String\",\n        RegularExpression: \"RegularExpression\",\n        Template: \"Template\",\n        JSXIdentifier: \"JSXIdentifier\",\n        JSXText: \"JSXText\"\n    };\n\n    /**\n     * Converts part of a template into an Esprima token.\n     * @param {AcornToken[]} tokens The Acorn tokens representing the template.\n     * @param {string} code The source code.\n     * @returns {EsprimaToken} The Esprima equivalent of the template token.\n     * @private\n     */\n    function convertTemplatePart(tokens, code) {\n        const firstToken = tokens[0],\n            lastTemplateToken = tokens[tokens.length - 1];\n\n        const token = {\n            type: Token.Template,\n            value: code.slice(firstToken.start, lastTemplateToken.end)\n        };\n\n        if (firstToken.loc) {\n            token.loc = {\n                start: firstToken.loc.start,\n                end: lastTemplateToken.loc.end\n            };\n        }\n\n        if (firstToken.range) {\n            token.start = firstToken.range[0];\n            token.end = lastTemplateToken.range[1];\n            token.range = [token.start, token.end];\n        }\n\n        return token;\n    }\n\n    /**\n     * Contains logic to translate Acorn tokens into Esprima tokens.\n     * @param {Object} acornTokTypes The Acorn token types.\n     * @param {string} code The source code Acorn is parsing. This is necessary\n     *      to correct the \"value\" property of some tokens.\n     * @constructor\n     */\n    function TokenTranslator(acornTokTypes, code) {\n\n        // token types\n        this._acornTokTypes = acornTokTypes;\n\n        // token buffer for templates\n        this._tokens = [];\n\n        // track the last curly brace\n        this._curlyBrace = null;\n\n        // the source code\n        this._code = code;\n\n    }\n\n    TokenTranslator.prototype = {\n        constructor: TokenTranslator,\n\n        /**\n         * Translates a single Esprima token to a single Acorn token. This may be\n         * inaccurate due to how templates are handled differently in Esprima and\n         * Acorn, but should be accurate for all other tokens.\n         * @param {AcornToken} token The Acorn token to translate.\n         * @param {Object} extra Espree extra object.\n         * @returns {EsprimaToken} The Esprima version of the token.\n         */\n        translate(token, extra) {\n\n            const type = token.type,\n                tt = this._acornTokTypes;\n\n            if (type === tt.name) {\n                token.type = Token.Identifier;\n\n                // TODO: See if this is an Acorn bug\n                if (token.value === \"static\") {\n                    token.type = Token.Keyword;\n                }\n\n                if (extra.ecmaVersion > 5 && (token.value === \"yield\" || token.value === \"let\")) {\n                    token.type = Token.Keyword;\n                }\n\n            } else if (type === tt.privateId) {\n                token.type = Token.PrivateIdentifier;\n\n            } else if (type === tt.semi || type === tt.comma ||\n                     type === tt.parenL || type === tt.parenR ||\n                     type === tt.braceL || type === tt.braceR ||\n                     type === tt.dot || type === tt.bracketL ||\n                     type === tt.colon || type === tt.question ||\n                     type === tt.bracketR || type === tt.ellipsis ||\n                     type === tt.arrow || type === tt.jsxTagStart ||\n                     type === tt.incDec || type === tt.starstar ||\n                     type === tt.jsxTagEnd || type === tt.prefix ||\n                     type === tt.questionDot ||\n                     (type.binop && !type.keyword) ||\n                     type.isAssign) {\n\n                token.type = Token.Punctuator;\n                token.value = this._code.slice(token.start, token.end);\n            } else if (type === tt.jsxName) {\n                token.type = Token.JSXIdentifier;\n            } else if (type.label === \"jsxText\" || type === tt.jsxAttrValueToken) {\n                token.type = Token.JSXText;\n            } else if (type.keyword) {\n                if (type.keyword === \"true\" || type.keyword === \"false\") {\n                    token.type = Token.Boolean;\n                } else if (type.keyword === \"null\") {\n                    token.type = Token.Null;\n                } else {\n                    token.type = Token.Keyword;\n                }\n            } else if (type === tt.num) {\n                token.type = Token.Numeric;\n                token.value = this._code.slice(token.start, token.end);\n            } else if (type === tt.string) {\n\n                if (extra.jsxAttrValueToken) {\n                    extra.jsxAttrValueToken = false;\n                    token.type = Token.JSXText;\n                } else {\n                    token.type = Token.String;\n                }\n\n                token.value = this._code.slice(token.start, token.end);\n            } else if (type === tt.regexp) {\n                token.type = Token.RegularExpression;\n                const value = token.value;\n\n                token.regex = {\n                    flags: value.flags,\n                    pattern: value.pattern\n                };\n                token.value = `/${value.pattern}/${value.flags}`;\n            }\n\n            return token;\n        },\n\n        /**\n         * Function to call during Acorn's onToken handler.\n         * @param {AcornToken} token The Acorn token.\n         * @param {Object} extra The Espree extra object.\n         * @returns {void}\n         */\n        onToken(token, extra) {\n\n            const that = this,\n                tt = this._acornTokTypes,\n                tokens = extra.tokens,\n                templateTokens = this._tokens;\n\n            /**\n             * Flushes the buffered template tokens and resets the template\n             * tracking.\n             * @returns {void}\n             * @private\n             */\n            function translateTemplateTokens() {\n                tokens.push(convertTemplatePart(that._tokens, that._code));\n                that._tokens = [];\n            }\n\n            if (token.type === tt.eof) {\n\n                // might be one last curlyBrace\n                if (this._curlyBrace) {\n                    tokens.push(this.translate(this._curlyBrace, extra));\n                }\n\n                return;\n            }\n\n            if (token.type === tt.backQuote) {\n\n                // if there's already a curly, it's not part of the template\n                if (this._curlyBrace) {\n                    tokens.push(this.translate(this._curlyBrace, extra));\n                    this._curlyBrace = null;\n                }\n\n                templateTokens.push(token);\n\n                // it's the end\n                if (templateTokens.length > 1) {\n                    translateTemplateTokens();\n                }\n\n                return;\n            }\n            if (token.type === tt.dollarBraceL) {\n                templateTokens.push(token);\n                translateTemplateTokens();\n                return;\n            }\n            if (token.type === tt.braceR) {\n\n                // if there's already a curly, it's not part of the template\n                if (this._curlyBrace) {\n                    tokens.push(this.translate(this._curlyBrace, extra));\n                }\n\n                // store new curly for later\n                this._curlyBrace = token;\n                return;\n            }\n            if (token.type === tt.template || token.type === tt.invalidTemplate) {\n                if (this._curlyBrace) {\n                    templateTokens.push(this._curlyBrace);\n                    this._curlyBrace = null;\n                }\n\n                templateTokens.push(token);\n                return;\n            }\n\n            if (this._curlyBrace) {\n                tokens.push(this.translate(this._curlyBrace, extra));\n                this._curlyBrace = null;\n            }\n\n            tokens.push(this.translate(token, extra));\n        }\n    };\n\n    //------------------------------------------------------------------------------\n    // Public\n    //------------------------------------------------------------------------------\n\n    return TokenTranslator;\n\n});\ndefine('skylark-espree/lib/options',[],function(){\n\n    /**\n     * @fileoverview A collection of methods for processing Espree's options.\n     * @author Kai Cataldo\n     */\n\n    //------------------------------------------------------------------------------\n    // Helpers\n    //------------------------------------------------------------------------------\n\n    const SUPPORTED_VERSIONS = [\n        3,\n        5,\n        6, // 2015\n        7, // 2016\n        8, // 2017\n        9, // 2018\n        10, // 2019\n        11, // 2020\n        12, // 2021\n        13, // 2022\n        14, // 2023\n        15 // 2024\n    ];\n\n    /**\n     * Get the latest ECMAScript version supported by Espree.\n     * @returns {number} The latest ECMAScript version.\n     */\n    function getLatestEcmaVersion() {\n        return SUPPORTED_VERSIONS[SUPPORTED_VERSIONS.length - 1];\n    }\n\n    /**\n     * Get the list of ECMAScript versions supported by Espree.\n     * @returns {number[]} An array containing the supported ECMAScript versions.\n     */\n    function getSupportedEcmaVersions() {\n        return [...SUPPORTED_VERSIONS];\n    }\n\n    /**\n     * Normalize ECMAScript version from the initial config\n     * @param {(number|\"latest\")} ecmaVersion ECMAScript version from the initial config\n     * @throws {Error} throws an error if the ecmaVersion is invalid.\n     * @returns {number} normalized ECMAScript version\n     */\n    function normalizeEcmaVersion(ecmaVersion = 'latest') { //5 lwf\n\n        let version = ecmaVersion === \"latest\" ? getLatestEcmaVersion() : ecmaVersion;\n\n        if (typeof version !== \"number\") {\n            throw new Error(`ecmaVersion must be a number or \"latest\". Received value of type ${typeof ecmaVersion} instead.`);\n        }\n\n        // Calculate ECMAScript edition number from official year version starting with\n        // ES2015, which corresponds with ES6 (or a difference of 2009).\n        if (version >= 2015) {\n            version -= 2009;\n        }\n\n        if (!SUPPORTED_VERSIONS.includes(version)) {\n            throw new Error(\"Invalid ecmaVersion.\");\n        }\n\n        return version;\n    }\n\n    /**\n     * Normalize sourceType from the initial config\n     * @param {string} sourceType to normalize\n     * @throws {Error} throw an error if sourceType is invalid\n     * @returns {string} normalized sourceType\n     */\n    function normalizeSourceType(sourceType = \"script\") {\n        if (sourceType === \"script\" || sourceType === \"module\") {\n            return sourceType;\n        }\n\n        if (sourceType === \"commonjs\") {\n            return \"script\";\n        }\n\n        throw new Error(\"Invalid sourceType.\");\n    }\n\n    /**\n     * Normalize parserOptions\n     * @param {Object} options the parser options to normalize\n     * @throws {Error} throw an error if found invalid option.\n     * @returns {Object} normalized options\n     */\n    function normalizeOptions(options) {\n        const ecmaVersion = normalizeEcmaVersion(options.ecmaVersion);\n        const sourceType = normalizeSourceType(options.sourceType);\n        const ranges = options.range === true;\n        const locations = options.loc === true;\n\n        if (ecmaVersion !== 3 && options.allowReserved) {\n\n            // a value of `false` is intentionally allowed here, so a shared config can overwrite it when needed\n            throw new Error(\"`allowReserved` is only supported when ecmaVersion is 3\");\n        }\n        if (typeof options.allowReserved !== \"undefined\" && typeof options.allowReserved !== \"boolean\") {\n            throw new Error(\"`allowReserved`, when present, must be `true` or `false`\");\n        }\n        const allowReserved = ecmaVersion === 3 ? (options.allowReserved || \"never\") : false;\n        const ecmaFeatures = options.ecmaFeatures || {};\n        const allowReturnOutsideFunction = options.sourceType === \"commonjs\" ||\n            Boolean(ecmaFeatures.globalReturn);\n\n        if (sourceType === \"module\" && ecmaVersion < 6) {\n            throw new Error(\"sourceType 'module' is not supported when ecmaVersion < 2015. Consider adding `{ ecmaVersion: 2015 }` to the parser options.\");\n        }\n\n        return Object.assign({}, options, {\n            ecmaVersion,\n            sourceType,\n            ranges,\n            locations,\n            allowReserved,\n            allowReturnOutsideFunction\n        });\n    }\n\n\n    return {\n        getLatestEcmaVersion,\n        getSupportedEcmaVersions,\n        normalizeOptions\n    };\n\n});\ndefine('skylark-espree/lib/espree',[\n    \"./token-translator\",\n    \"./options\"\n],function(TokenTranslator,options){\n\n    /* eslint-disable no-param-reassign*/\n    const  { normalizeOptions } = options;\n\n\n    const STATE = Symbol(\"espree's internal state\");\n    const ESPRIMA_FINISH_NODE = Symbol(\"espree's esprimaFinishNode\");\n\n\n    /**\n     * Converts an Acorn comment to a Esprima comment.\n     * @param {boolean} block True if it's a block comment, false if not.\n     * @param {string} text The text of the comment.\n     * @param {int} start The index at which the comment starts.\n     * @param {int} end The index at which the comment ends.\n     * @param {Location} startLoc The location at which the comment starts.\n     * @param {Location} endLoc The location at which the comment ends.\n     * @param {string} code The source code being parsed.\n     * @returns {Object} The comment object.\n     * @private\n     */\n    function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code) {\n        let type;\n\n        if (block) {\n            type = \"Block\";\n        } else if (code.slice(start, start + 2) === \"#!\") {\n            type = \"Hashbang\";\n        } else {\n            type = \"Line\";\n        }\n\n        const comment = {\n            type,\n            value: text\n        };\n\n        if (typeof start === \"number\") {\n            comment.start = start;\n            comment.end = end;\n            comment.range = [start, end];\n        }\n\n        if (typeof startLoc === \"object\") {\n            comment.loc = {\n                start: startLoc,\n                end: endLoc\n            };\n        }\n\n        return comment;\n    }\n\n    return () => Parser => {\n        const tokTypes = Object.assign({}, Parser.acorn.tokTypes);\n\n        if (Parser.acornJsx) {\n            Object.assign(tokTypes, Parser.acornJsx.tokTypes);\n        }\n\n        return class Espree extends Parser {\n            constructor(opts, code) {\n                if (typeof opts !== \"object\" || opts === null) {\n                    opts = {};\n                }\n                if (typeof code !== \"string\" && !(code instanceof String)) {\n                    code = String(code);\n                }\n\n                // save original source type in case of commonjs\n                const originalSourceType = opts.sourceType;\n                const options = normalizeOptions(opts);\n                const ecmaFeatures = options.ecmaFeatures || {};\n                const tokenTranslator =\n                    options.tokens === true\n                        ? new TokenTranslator(tokTypes, code)\n                        : null;\n\n                /*\n                 * Data that is unique to Espree and is not represented internally\n                 * in Acorn.\n                 *\n                 * For ES2023 hashbangs, Espree will call `onComment()` during the\n                 * constructor, so we must define state before having access to\n                 * `this`.\n                 */\n                const state = {\n                    originalSourceType: originalSourceType || options.sourceType,\n                    tokens: tokenTranslator ? [] : null,\n                    comments: options.comment === true ? [] : null,\n                    impliedStrict: ecmaFeatures.impliedStrict === true && options.ecmaVersion >= 5,\n                    ecmaVersion: options.ecmaVersion,\n                    jsxAttrValueToken: false,\n                    lastToken: null,\n                    templateElements: []\n                };\n\n                // Initialize acorn parser.\n                super({\n\n                    // do not use spread, because we don't want to pass any unknown options to acorn\n                    ecmaVersion: options.ecmaVersion,\n                    sourceType: options.sourceType,\n                    ranges: options.ranges,\n                    locations: options.locations,\n                    allowReserved: options.allowReserved,\n\n                    // Truthy value is true for backward compatibility.\n                    allowReturnOutsideFunction: options.allowReturnOutsideFunction,\n\n                    // Collect tokens\n                    onToken: token => {\n                        if (tokenTranslator) {\n\n                            // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.\n                            tokenTranslator.onToken(token, state);\n                        }\n                        if (token.type !== tokTypes.eof) {\n                            state.lastToken = token;\n                        }\n                    },\n\n                    // Collect comments\n                    onComment: (block, text, start, end, startLoc, endLoc) => {\n                        if (state.comments) {\n                            const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code);\n\n                            state.comments.push(comment);\n                        }\n                    }\n                }, code);\n\n                /*\n                 * We put all of this data into a symbol property as a way to avoid\n                 * potential naming conflicts with future versions of Acorn.\n                 */\n                this[STATE] = state;\n            }\n\n            tokenize() {\n                do {\n                    this.next();\n                } while (this.type !== tokTypes.eof);\n\n                // Consume the final eof token\n                this.next();\n\n                const extra = this[STATE];\n                const tokens = extra.tokens;\n\n                if (extra.comments) {\n                    tokens.comments = extra.comments;\n                }\n\n                return tokens;\n            }\n\n            finishNode(...args) {\n                const result = super.finishNode(...args);\n\n                return this[ESPRIMA_FINISH_NODE](result);\n            }\n\n            finishNodeAt(...args) {\n                const result = super.finishNodeAt(...args);\n\n                return this[ESPRIMA_FINISH_NODE](result);\n            }\n\n            parse() {\n                const extra = this[STATE];\n                const program = super.parse();\n\n                program.sourceType = extra.originalSourceType;\n\n                if (extra.comments) {\n                    program.comments = extra.comments;\n                }\n                if (extra.tokens) {\n                    program.tokens = extra.tokens;\n                }\n\n                /*\n                 * Adjust opening and closing position of program to match Esprima.\n                 * Acorn always starts programs at range 0 whereas Esprima starts at the\n                 * first AST node's start (the only real difference is when there's leading\n                 * whitespace or leading comments). Acorn also counts trailing whitespace\n                 * as part of the program whereas Esprima only counts up to the last token.\n                 */\n                if (program.body.length) {\n                    const [firstNode] = program.body;\n\n                    if (program.range) {\n                        program.range[0] = firstNode.range[0];\n                    }\n                    if (program.loc) {\n                        program.loc.start = firstNode.loc.start;\n                    }\n                    program.start = firstNode.start;\n                }\n                if (extra.lastToken) {\n                    if (program.range) {\n                        program.range[1] = extra.lastToken.range[1];\n                    }\n                    if (program.loc) {\n                        program.loc.end = extra.lastToken.loc.end;\n                    }\n                    program.end = extra.lastToken.end;\n                }\n\n\n                /*\n                 * https://github.com/eslint/espree/issues/349\n                 * Ensure that template elements have correct range information.\n                 * This is one location where Acorn produces a different value\n                 * for its start and end properties vs. the values present in the\n                 * range property. In order to avoid confusion, we set the start\n                 * and end properties to the values that are present in range.\n                 * This is done here, instead of in finishNode(), because Acorn\n                 * uses the values of start and end internally while parsing, making\n                 * it dangerous to change those values while parsing is ongoing.\n                 * By waiting until the end of parsing, we can safely change these\n                 * values without affect any other part of the process.\n                 */\n                this[STATE].templateElements.forEach(templateElement => {\n                    const startOffset = -1;\n                    const endOffset = templateElement.tail ? 1 : 2;\n\n                    templateElement.start += startOffset;\n                    templateElement.end += endOffset;\n\n                    if (templateElement.range) {\n                        templateElement.range[0] += startOffset;\n                        templateElement.range[1] += endOffset;\n                    }\n\n                    if (templateElement.loc) {\n                        templateElement.loc.start.column += startOffset;\n                        templateElement.loc.end.column += endOffset;\n                    }\n                });\n\n                return program;\n            }\n\n            parseTopLevel(node) {\n                if (this[STATE].impliedStrict) {\n                    this.strict = true;\n                }\n                return super.parseTopLevel(node);\n            }\n\n            /**\n             * Overwrites the default raise method to throw Esprima-style errors.\n             * @param {int} pos The position of the error.\n             * @param {string} message The error message.\n             * @throws {SyntaxError} A syntax error.\n             * @returns {void}\n             */\n            raise(pos, message) {\n                const loc = Parser.acorn.getLineInfo(this.input, pos);\n                const err = new SyntaxError(message);\n\n                err.index = pos;\n                err.lineNumber = loc.line;\n                err.column = loc.column + 1; // acorn uses 0-based columns\n                throw err;\n            }\n\n            /**\n             * Overwrites the default raise method to throw Esprima-style errors.\n             * @param {int} pos The position of the error.\n             * @param {string} message The error message.\n             * @throws {SyntaxError} A syntax error.\n             * @returns {void}\n             */\n            raiseRecoverable(pos, message) {\n                this.raise(pos, message);\n            }\n\n            /**\n             * Overwrites the default unexpected method to throw Esprima-style errors.\n             * @param {int} pos The position of the error.\n             * @throws {SyntaxError} A syntax error.\n             * @returns {void}\n             */\n            unexpected(pos) {\n                let message = \"Unexpected token\";\n\n                if (pos !== null && pos !== void 0) {\n                    this.pos = pos;\n\n                    if (this.options.locations) {\n                        while (this.pos < this.lineStart) {\n                            this.lineStart = this.input.lastIndexOf(\"\\n\", this.lineStart - 2) + 1;\n                            --this.curLine;\n                        }\n                    }\n\n                    this.nextToken();\n                }\n\n                if (this.end > this.start) {\n                    message += ` ${this.input.slice(this.start, this.end)}`;\n                }\n\n                this.raise(this.start, message);\n            }\n\n            /*\n            * Esprima-FB represents JSX strings as tokens called \"JSXText\", but Acorn-JSX\n            * uses regular tt.string without any distinction between this and regular JS\n            * strings. As such, we intercept an attempt to read a JSX string and set a flag\n            * on extra so that when tokens are converted, the next token will be switched\n            * to JSXText via onToken.\n            */\n            jsx_readString(quote) { // eslint-disable-line camelcase\n                const result = super.jsx_readString(quote);\n\n                if (this.type === tokTypes.string) {\n                    this[STATE].jsxAttrValueToken = true;\n                }\n                return result;\n            }\n\n            /**\n             * Performs last-minute Esprima-specific compatibility checks and fixes.\n             * @param {ASTNode} result The node to check.\n             * @returns {ASTNode} The finished node.\n             */\n            [ESPRIMA_FINISH_NODE](result) {\n\n                // Acorn doesn't count the opening and closing backticks as part of templates\n                // so we have to adjust ranges/locations appropriately.\n                if (result.type === \"TemplateElement\") {\n\n                    // save template element references to fix start/end later\n                    this[STATE].templateElements.push(result);\n                }\n\n                if (result.type.includes(\"Function\") && !result.generator) {\n                    result.generator = false;\n                }\n\n                return result;\n            }\n        };\n    };\n\n\n});\ndefine('skylark-espree/lib/version',[],function(){\n\tconst version = \"main\";\n\n\treturn version;\n\n});\n\ndefine('skylark-espree/eslint-visitor-keys',[],function(){\r\n\t/**\r\n\t * @typedef {{ readonly [type: string]: ReadonlyArray<string> }} VisitorKeys\r\n\t */\r\n\r\n\t/**\r\n\t * @type {VisitorKeys}\r\n\t */\r\n\tconst KEYS = {\r\n\t    ArrayExpression: [\r\n\t        \"elements\"\r\n\t    ],\r\n\t    ArrayPattern: [\r\n\t        \"elements\"\r\n\t    ],\r\n\t    ArrowFunctionExpression: [\r\n\t        \"params\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    AssignmentExpression: [\r\n\t        \"left\",\r\n\t        \"right\"\r\n\t    ],\r\n\t    AssignmentPattern: [\r\n\t        \"left\",\r\n\t        \"right\"\r\n\t    ],\r\n\t    AwaitExpression: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    BinaryExpression: [\r\n\t        \"left\",\r\n\t        \"right\"\r\n\t    ],\r\n\t    BlockStatement: [\r\n\t        \"body\"\r\n\t    ],\r\n\t    BreakStatement: [\r\n\t        \"label\"\r\n\t    ],\r\n\t    CallExpression: [\r\n\t        \"callee\",\r\n\t        \"arguments\"\r\n\t    ],\r\n\t    CatchClause: [\r\n\t        \"param\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    ChainExpression: [\r\n\t        \"expression\"\r\n\t    ],\r\n\t    ClassBody: [\r\n\t        \"body\"\r\n\t    ],\r\n\t    ClassDeclaration: [\r\n\t        \"id\",\r\n\t        \"superClass\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    ClassExpression: [\r\n\t        \"id\",\r\n\t        \"superClass\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    ConditionalExpression: [\r\n\t        \"test\",\r\n\t        \"consequent\",\r\n\t        \"alternate\"\r\n\t    ],\r\n\t    ContinueStatement: [\r\n\t        \"label\"\r\n\t    ],\r\n\t    DebuggerStatement: [],\r\n\t    DoWhileStatement: [\r\n\t        \"body\",\r\n\t        \"test\"\r\n\t    ],\r\n\t    EmptyStatement: [],\r\n\t    ExperimentalRestProperty: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    ExperimentalSpreadProperty: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    ExportAllDeclaration: [\r\n\t        \"exported\",\r\n\t        \"source\"\r\n\t    ],\r\n\t    ExportDefaultDeclaration: [\r\n\t        \"declaration\"\r\n\t    ],\r\n\t    ExportNamedDeclaration: [\r\n\t        \"declaration\",\r\n\t        \"specifiers\",\r\n\t        \"source\"\r\n\t    ],\r\n\t    ExportSpecifier: [\r\n\t        \"exported\",\r\n\t        \"local\"\r\n\t    ],\r\n\t    ExpressionStatement: [\r\n\t        \"expression\"\r\n\t    ],\r\n\t    ForInStatement: [\r\n\t        \"left\",\r\n\t        \"right\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    ForOfStatement: [\r\n\t        \"left\",\r\n\t        \"right\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    ForStatement: [\r\n\t        \"init\",\r\n\t        \"test\",\r\n\t        \"update\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    FunctionDeclaration: [\r\n\t        \"id\",\r\n\t        \"params\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    FunctionExpression: [\r\n\t        \"id\",\r\n\t        \"params\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    Identifier: [],\r\n\t    IfStatement: [\r\n\t        \"test\",\r\n\t        \"consequent\",\r\n\t        \"alternate\"\r\n\t    ],\r\n\t    ImportDeclaration: [\r\n\t        \"specifiers\",\r\n\t        \"source\"\r\n\t    ],\r\n\t    ImportDefaultSpecifier: [\r\n\t        \"local\"\r\n\t    ],\r\n\t    ImportExpression: [\r\n\t        \"source\"\r\n\t    ],\r\n\t    ImportNamespaceSpecifier: [\r\n\t        \"local\"\r\n\t    ],\r\n\t    ImportSpecifier: [\r\n\t        \"imported\",\r\n\t        \"local\"\r\n\t    ],\r\n\t    JSXAttribute: [\r\n\t        \"name\",\r\n\t        \"value\"\r\n\t    ],\r\n\t    JSXClosingElement: [\r\n\t        \"name\"\r\n\t    ],\r\n\t    JSXClosingFragment: [],\r\n\t    JSXElement: [\r\n\t        \"openingElement\",\r\n\t        \"children\",\r\n\t        \"closingElement\"\r\n\t    ],\r\n\t    JSXEmptyExpression: [],\r\n\t    JSXExpressionContainer: [\r\n\t        \"expression\"\r\n\t    ],\r\n\t    JSXFragment: [\r\n\t        \"openingFragment\",\r\n\t        \"children\",\r\n\t        \"closingFragment\"\r\n\t    ],\r\n\t    JSXIdentifier: [],\r\n\t    JSXMemberExpression: [\r\n\t        \"object\",\r\n\t        \"property\"\r\n\t    ],\r\n\t    JSXNamespacedName: [\r\n\t        \"namespace\",\r\n\t        \"name\"\r\n\t    ],\r\n\t    JSXOpeningElement: [\r\n\t        \"name\",\r\n\t        \"attributes\"\r\n\t    ],\r\n\t    JSXOpeningFragment: [],\r\n\t    JSXSpreadAttribute: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    JSXSpreadChild: [\r\n\t        \"expression\"\r\n\t    ],\r\n\t    JSXText: [],\r\n\t    LabeledStatement: [\r\n\t        \"label\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    Literal: [],\r\n\t    LogicalExpression: [\r\n\t        \"left\",\r\n\t        \"right\"\r\n\t    ],\r\n\t    MemberExpression: [\r\n\t        \"object\",\r\n\t        \"property\"\r\n\t    ],\r\n\t    MetaProperty: [\r\n\t        \"meta\",\r\n\t        \"property\"\r\n\t    ],\r\n\t    MethodDefinition: [\r\n\t        \"key\",\r\n\t        \"value\"\r\n\t    ],\r\n\t    NewExpression: [\r\n\t        \"callee\",\r\n\t        \"arguments\"\r\n\t    ],\r\n\t    ObjectExpression: [\r\n\t        \"properties\"\r\n\t    ],\r\n\t    ObjectPattern: [\r\n\t        \"properties\"\r\n\t    ],\r\n\t    PrivateIdentifier: [],\r\n\t    Program: [\r\n\t        \"body\"\r\n\t    ],\r\n\t    Property: [\r\n\t        \"key\",\r\n\t        \"value\"\r\n\t    ],\r\n\t    PropertyDefinition: [\r\n\t        \"key\",\r\n\t        \"value\"\r\n\t    ],\r\n\t    RestElement: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    ReturnStatement: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    SequenceExpression: [\r\n\t        \"expressions\"\r\n\t    ],\r\n\t    SpreadElement: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    StaticBlock: [\r\n\t        \"body\"\r\n\t    ],\r\n\t    Super: [],\r\n\t    SwitchCase: [\r\n\t        \"test\",\r\n\t        \"consequent\"\r\n\t    ],\r\n\t    SwitchStatement: [\r\n\t        \"discriminant\",\r\n\t        \"cases\"\r\n\t    ],\r\n\t    TaggedTemplateExpression: [\r\n\t        \"tag\",\r\n\t        \"quasi\"\r\n\t    ],\r\n\t    TemplateElement: [],\r\n\t    TemplateLiteral: [\r\n\t        \"quasis\",\r\n\t        \"expressions\"\r\n\t    ],\r\n\t    ThisExpression: [],\r\n\t    ThrowStatement: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    TryStatement: [\r\n\t        \"block\",\r\n\t        \"handler\",\r\n\t        \"finalizer\"\r\n\t    ],\r\n\t    UnaryExpression: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    UpdateExpression: [\r\n\t        \"argument\"\r\n\t    ],\r\n\t    VariableDeclaration: [\r\n\t        \"declarations\"\r\n\t    ],\r\n\t    VariableDeclarator: [\r\n\t        \"id\",\r\n\t        \"init\"\r\n\t    ],\r\n\t    WhileStatement: [\r\n\t        \"test\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    WithStatement: [\r\n\t        \"object\",\r\n\t        \"body\"\r\n\t    ],\r\n\t    YieldExpression: [\r\n\t        \"argument\"\r\n\t    ]\r\n\t};\r\n\r\n\t// Types.\r\n\tconst NODE_TYPES = Object.keys(KEYS);\r\n\r\n\t// Freeze the keys.\r\n\tfor (const type of NODE_TYPES) {\r\n\t    Object.freeze(KEYS[type]);\r\n\t}\r\n\tObject.freeze(KEYS);\r\n\r\n\t/**\r\n\t * @typedef {import('./visitor-keys.js').VisitorKeys} VisitorKeys\r\n\t */\r\n\r\n\t// List to ignore keys.\r\n\tconst KEY_BLACKLIST = new Set([\r\n\t    \"parent\",\r\n\t    \"leadingComments\",\r\n\t    \"trailingComments\"\r\n\t]);\r\n\r\n\t/**\r\n\t * Check whether a given key should be used or not.\r\n\t * @param {string} key The key to check.\r\n\t * @returns {boolean} `true` if the key should be used.\r\n\t */\r\n\tfunction filterKey(key) {\r\n\t    return !KEY_BLACKLIST.has(key) && key[0] !== \"_\";\r\n\t}\r\n\r\n\t/**\r\n\t * Get visitor keys of a given node.\r\n\t * @param {object} node The AST node to get keys.\r\n\t * @returns {readonly string[]} Visitor keys of the node.\r\n\t */\r\n\tfunction getKeys(node) {\r\n\t    return Object.keys(node).filter(filterKey);\r\n\t}\r\n\r\n\t// Disable valid-jsdoc rule because it reports syntax error on the type of @returns.\r\n\t// eslint-disable-next-line valid-jsdoc\r\n\t/**\r\n\t * Make the union set with `KEYS` and given keys.\r\n\t * @param {VisitorKeys} additionalKeys The additional keys.\r\n\t * @returns {VisitorKeys} The union set.\r\n\t */\r\n\tfunction unionWith(additionalKeys) {\r\n\t    const retv = /** @type {{\r\n\t        [type: string]: ReadonlyArray<string>\r\n\t    }} */ (Object.assign({}, KEYS));\r\n\r\n\t    for (const type of Object.keys(additionalKeys)) {\r\n\t        if (Object.prototype.hasOwnProperty.call(retv, type)) {\r\n\t            const keys = new Set(additionalKeys[type]);\r\n\r\n\t            for (const key of retv[type]) {\r\n\t                keys.add(key);\r\n\t            }\r\n\r\n\t            retv[type] = Object.freeze(Array.from(keys));\r\n\t        } else {\r\n\t            retv[type] = Object.freeze(Array.from(additionalKeys[type]));\r\n\t        }\r\n\t    }\r\n\r\n\t    return Object.freeze(retv);\r\n\t}\r\n\r\n\treturn  {\r\n\t  KEYS,\r\n\t  getKeys,\r\n\t  unionWith\r\n\t};\r\n\r\n});\ndefine('skylark-espree/espree',[\n    \"skylark-acorn\",\n    \"skylark-acorn/plugins/jsx\",\n    \"./lib/espree\",\n    \"./lib/version\",\n    \"./lib/options\",\n    \"./eslint-visitor-keys\"\n],function(\n    acorn,\n    jsx,\n    espree,\n    espreeVersion,\n    options,\n    visitorKeys\n){\n\n\n    /**\n     * @fileoverview Main Espree file that converts Acorn into Esprima output.\n     *\n     * This file contains code from the following MIT-licensed projects:\n     * 1. Acorn\n     * 2. Babylon\n     * 3. Babel-ESLint\n     *\n     * This file also contains code from Esprima, which is BSD licensed.\n     *\n     * Acorn is Copyright 2012-2015 Acorn Contributors (https://github.com/marijnh/acorn/blob/master/AUTHORS)\n     * Babylon is Copyright 2014-2015 various contributors (https://github.com/babel/babel/blob/master/packages/babylon/AUTHORS)\n     * Babel-ESLint is Copyright 2014-2015 Sebastian McKenzie <sebmck@gmail.com>\n     *\n     * Redistribution and use in source and binary forms, with or without\n     * modification, are permitted provided that the following conditions are met:\n     *\n     * * Redistributions of source code must retain the above copyright\n     *   notice, this list of conditions and the following disclaimer.\n     * * Redistributions in binary form must reproduce the above copyright\n     *   notice, this list of conditions and the following disclaimer in the\n     *   documentation and/or other materials provided with the distribution.\n     *\n     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n     * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n     * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n     * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n     * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n     * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n     * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n     *\n     * Esprima is Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.\n     *\n     * Redistribution and use in source and binary forms, with or without\n     * modification, are permitted provided that the following conditions are met:\n     *\n     *   * Redistributions of source code must retain the above copyright\n     *     notice, this list of conditions and the following disclaimer.\n     *   * Redistributions in binary form must reproduce the above copyright\n     *     notice, this list of conditions and the following disclaimer in the\n     *     documentation and/or other materials provided with the distribution.\n     *\n     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n     * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n     * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n     * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n     * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n     * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n     * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n     */\n    /* eslint no-undefined:0, no-use-before-define: 0 */\n\n    const  { getLatestEcmaVersion, getSupportedEcmaVersions } = options;\n\n\n    // To initialize lazily.\n    const parsers = {\n        _regular: null,\n        _jsx: null,\n\n        get regular() {\n            if (this._regular === null) {\n                this._regular = acorn.Parser.extend(espree());\n            }\n            return this._regular;\n        },\n\n        get jsx() {\n            if (this._jsx === null) {\n                this._jsx = acorn.Parser.extend(jsx(), espree());\n            }\n            return this._jsx;\n        },\n\n        get(options) {\n            const useJsx = Boolean(\n                options &&\n                options.ecmaFeatures &&\n                options.ecmaFeatures.jsx\n            );\n\n            return useJsx ? this.jsx : this.regular;\n        }\n    };\n\n    //------------------------------------------------------------------------------\n    // Tokenizer\n    //------------------------------------------------------------------------------\n\n    /**\n     * Tokenizes the given code.\n     * @param {string} code The code to tokenize.\n     * @param {Object} options Options defining how to tokenize.\n     * @returns {Token[]} An array of tokens.\n     * @throws {SyntaxError} If the input code is invalid.\n     * @private\n     */\n    function tokenize(code, options) {\n        const Parser = parsers.get(options);\n\n        // Ensure to collect tokens.\n        if (!options || options.tokens !== true) {\n            options = Object.assign({}, options, { tokens: true }); // eslint-disable-line no-param-reassign\n        }\n\n        return new Parser(options, code).tokenize();\n    }\n\n    //------------------------------------------------------------------------------\n    // Parser\n    //------------------------------------------------------------------------------\n\n    /**\n     * Parses the given code.\n     * @param {string} code The code to tokenize.\n     * @param {Object} options Options defining how to tokenize.\n     * @returns {ASTNode} The \"Program\" AST node.\n     * @throws {SyntaxError} If the input code is invalid.\n     */\n     function parse(code, options) {\n        const Parser = parsers.get(options);\n\n        return new Parser(options, code).parse();\n    }\n\n    //------------------------------------------------------------------------------\n    // Public\n    //------------------------------------------------------------------------------\n\n    const version = espreeVersion;\n    const name = \"espree\";\n\n    /* istanbul ignore next */\n    const VisitorKeys = (function() {\n        return visitorKeys.KEYS;\n    }());\n\n    // Derive node types from VisitorKeys\n    /* istanbul ignore next */\n    const Syntax = (function() {\n        let key,\n            types = {};\n\n        if (typeof Object.create === \"function\") {\n            types = Object.create(null);\n        }\n\n        for (key in VisitorKeys) {\n            if (Object.hasOwnProperty.call(VisitorKeys, key)) {\n                types[key] = key;\n            }\n        }\n\n        if (typeof Object.freeze === \"function\") {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n\n    const latestEcmaVersion = getLatestEcmaVersion();\n\n    const supportedEcmaVersions = getSupportedEcmaVersions();\n\n    return {\n        tokenize,\n        parse,\n        version,\n        name,\n        VisitorKeys,\n        Syntax,\n        latestEcmaVersion,\n        supportedEcmaVersions\n    }\n\n});\n\ndefine('skylark-espree/main',[\r\n\t\"./espree\"\r\n],function(espree){\r\n\treturn espree;\r\n});\ndefine('skylark-espree', ['skylark-espree/main'], function (main) { return main; });\n\n"]}